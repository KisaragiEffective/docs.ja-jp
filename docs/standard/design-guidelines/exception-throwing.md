---
description: '詳細情報: 例外のスロー'
title: 例外のスロー
ms.date: 10/22/2008
helpviewer_keywords:
- exceptions, throwing
- explicitly throwing exceptions
- throwing exceptions, design guidelines
ms.assetid: 5388e02b-52f5-460e-a2b5-eeafe60eeebe
ms.openlocfilehash: b1cf7a4eecc32a9f76ea06c47dd6c16d3afe5470
ms.sourcegitcommit: ddf7edb67715a5b9a45e3dd44536dabc153c1de0
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 02/06/2021
ms.locfileid: "99642137"
---
# <a name="exception-throwing"></a>例外のスロー

このセクションで説明する例外のスローに関するガイドラインでは、実行失敗の意味を適切に定義する必要があります。 実行失敗は、メンバーが実行するように設計されていたこと (メンバー名が示すもの) を実行できない場合に常に発生します。 たとえば、`OpenFile` メソッドが開かれたファイルのハンドルを呼び出し元に返すことができない場合、実行失敗と見なされます。

 ほとんどの開発者は、0 による除算や null 参照などの使用エラーに対し、例外を使用することに慣れています。 フレームワークでは、実行エラーを含むすべてのエラー状態に対して例外が使用されます。

 ❌ エラー コードを返さないでください。

 例外は、フレームワークでエラーを報告するための主な手段です。

 ✔️ 例外をスローすることにより、実行失敗を報告します。

 ✔️ 実行を続けると安全ではない状況がコードで発生した場合は、例外をスローするのではなく、`System.Environment.FailFast` (.NET Framework 2.0 の機能) を呼び出してプロセスを終了することを検討します。

 ❌ 可能であれば、通常の制御フローには例外を使用しないでください。

 システム障害や競合状態の可能性がある操作の場合を除き、フレームワーク デザイナーは、ユーザーが例外をスローしないコードを記述できるように、API を設計する必要があります。 たとえば、例外をスローしないコードをユーザーが記述できるように、メンバーを呼び出す前に事前条件をチェックする手段を提供できます。

 通常、別のメンバーの事前条件をチェックするために使用されるメンバーはテスターと呼ばれ、実際に作業を行うメンバーはドゥーアーと呼ばれます。

 Tester-Doer パターンを使用すると許容できないパフォーマンスのオーバーヘッドが発生する場合があります。 そのような場合は、いわゆる Try-Parse パターンを検討する必要があります (詳細については、「[例外とパフォーマンス](exceptions-and-performance.md)」を参照)。

 ✔️ 例外をスローした場合のパフォーマンスへの影響を考慮します。 1 秒間に 100 回を超える割合でスローすると、ほとんどのアプリケーションでパフォーマンスが著しく低下する可能性があります。

 ✔️ パブリックに呼び出し可能なメンバーによって、(システム障害ではなく) メンバー コントラクトの違反のためにスローされるすべての例外をドキュメントに記載し、それらをコントラクトの一部として処理します。

 コントラクトの一部である例外は、バージョン間で変更することはできません (つまり、例外の種類を変更してはならず、新しい例外を追加してはなりません)。

 ❌ 何らかのオプションに基づいてスローが可能または不可能なパブリック メンバーを使用しないでください。

 ❌ 戻り値または `out` パラメーターとして例外を返すパブリック メンバーを使用しないでください。

 パブリック API から例外をスローするのではなく返すと、例外ベースのエラー報告の利点の多くが損なわれます。

 ✔️ 例外ビルダーメ ソッドを使用することを検討します。

 同じ例外を異なる場所からスローすることがよくあります。 コードの肥大化を回避するため、例外を作成してプロパティを初期化するヘルパー メソッドを使用します。

 また、例外をスローするメンバーはインライン展開されません。 throw ステートメントをビルダー内で移動すると、そのメンバーがインライン化される可能性があります。

 ❌ 例外フィルター ブロックから例外をスローしないでください。

 例外フィルターで例外が発生すると、CLR によって例外がキャッチされ、フィルターからは false が返されます。 この動作は、実行して明示的に false を返すフィルターと区別できないため、デバッグが非常に困難です。

 ❌ finally ブロックから明示的に例外をスローしないでください。 スローするメソッドの呼び出しによって発生する暗黙的にスローされる例外は、許容されます。

 *Portions © 2005, 2009 Microsoft Corporation.All rights reserved.*

 *2008 年 10 月 22 日に Microsoft Windows Development シリーズの一部として、Addison-Wesley Professional によって発行された、Krzysztof Cwalina および Brad Abrams による「[Framework Design Guidelines: Conventions, Idioms, and Patterns for Reusable .NET Libraries, 2nd Edition](https://www.informit.com/store/framework-design-guidelines-conventions-idioms-and-9780321545619)」 (フレームワーク デザイン ガイドライン: 再利用可能な .NET ライブラリの規則、用法、パターン、第 2 版) から Pearson Education, Inc. の許可を得て再印刷されています。*

## <a name="see-also"></a>関連項目

- [フレームワーク デザインのガイドライン](index.md)
- [例外のデザインのガイドライン](exceptions.md)
