---
title: null 許容参照型を使用するようにコードベースを更新する
description: null 許容参照型を使用するようにコードベースをアップグレードするための最適な方法を選択します。
ms.technology: csharp-null-safety
ms.date: 07/31/2019
ms.openlocfilehash: fff9ce4d053cc2543b0148d70435bdc793ecccd7
ms.sourcegitcommit: 05d0087dfca85aac9ca2960f86c5efd218bf833f
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/27/2021
ms.locfileid: "105637161"
---
# <a name="update-libraries-to-use-nullable-reference-types-and-communicate-nullable-rules-to-callers"></a>null 許容参照型を使用するようにライブラリを更新し、null 許容規則を呼び出し元に伝える

[null 許容参照型](nullable-references.md)を追加するということは、すべての変数で `null` 値が許可または要求されるかどうかを宣言できることを意味します。 さらに、いくつかの属性 (`AllowNull`、`DisallowNull`、`MaybeNull`、`NotNull`、`NotNullWhen`、`MaybeNullWhen`、`NotNullIfNotNull`) を適用して、引数と戻り値の null 状態を完全に記述することもできます。 それにより、コードを記述するときに優れたエクスペリエンスが提供されます。 null 非許容変数が `null` に設定される可能性がある場合は、警告が表示されます。 null 許容変数が逆参照される前に null チェックが行われていない場合、警告が表示されます。 ライブラリの更新には時間がかかることがありますが、メリットにはそれだけの価値があります。 "*どのようなときに*" `null` 値が許可または禁止されるかについて、コンパイラに提供する情報が多いほど、より適切な警告が API のユーザーに示されます。 よくある例から始めましょう。 ライブラリに、リソース文字列を取得するための次の API があるとします。

```csharp
bool TryGetMessage(string key, out string message)
```

前述の例では、.NET のよくある `Try*` パターンに従っています。 この API には、2 つの参照引数 (`key` および `message` パラメーター) があります。 この API には、これらの引数の null 性に関連する次の規則があります。

- 呼び出し元では、`key` の引数として `null` を渡すことはできません。
- 呼び出し元では、`message` の引数として、値が `null` の変数を渡すことができます。
- `TryGetMessage` メソッドから `true` が返された場合、`message` の値は null ではありません。 戻り値が `false,` である場合、`message` (およびその null 状態) の値は null です。

`key` の規則は、変数型によって完全に表すことができます。`key` は null 非許容参照型である必要があります。 `message` パラメーターはより複雑です。 引数として `null` が許可されますが、成功した場合、`out` 引数が null でないことが保証されます。 これらのシナリオでは、予測を記述するために、より豊富なボキャブラリが必要です。

null 許容参照用にライブラリを更新すると、一部の変数や型名に `?` を指定する以上のことが必要になります。 前の例では、API を調べて、各入力引数について想定されることを検討する必要があることが示されています。 戻り値の保証と、メソッドから戻るときの `out` または `ref` 引数について検討します。 次に、それらの規則をコンパイラに通知します。呼び出し元がそれらの規則を守らないと、コンパイラによって警告が示されます。

この作業には時間がかかります。 他の要件とバランスを取りながら、ライブラリまたはアプリケーションを null 許容対応にするための戦略から始めましょう。 実行中の開発で null 許容参照型を有効にするときにバランスを取る方法について説明します。 ジェネリック型定義の課題について学習します。 属性を適用して、個々の API の事前条件と事後条件を記述する方法について学習します。

## <a name="choose-a-strategy-for-nullable-reference-types"></a>null 許容参照型に関する戦略を選択する

最初に選択することは、null 許容参照型を既定でオンまたはオフにするかどうかです。 次の 2 つの方法があります。

- プロジェクト全体について null 許容参照型を有効にし、準備ができていないものをコードで無効にします。
- null 許容参照型の注釈が付けられたコードについてのみ、null 許容参照型を有効にします。

最初の方法は、null 許容参照型対応に更新するときに、他の機能をライブラリに追加する場合に最も適しています。 すべての新規開発は null 許容対応です。 既存のコードを更新するときに、それらのクラスで null 許容参照型を有効にします。

この最初の戦略に従う場合は、次の手順のようにします。

1. *csproj* ファイルに `<Nullable>enable</Nullable>` 要素を追加することにより、プロジェクト全体で null 許容参照型を有効にします。
1. プロジェクト内のすべてのソース ファイルに `#nullable disable` プラグマを追加します。
1. 各ファイルの作業を行うときに、プラグマを削除し、警告が発生したら対処します。

この最初の戦略の場合、すべてのファイルにプラグマを追加するための事前作業が多くなります。 利点は、プロジェクトに追加されるすべての新しいコード ファイルで null 許容が有効になることです。 新しい作業はすべて null 許容対応になります。既存のコードのみを更新する必要があります。

2 番目の戦略は、ライブラリが安定している場合に適しており、開発の主な目的は null 許容参照型を導入することになります。 API に注釈を付けるときに、null 許容参照型を有効にします。 終了した時点で、プロジェクト全体について null 許容参照型が有効になります。

この 2 番目の戦略に従う場合は、次の手順のようにします。

1. null 許容対応にするファイルに `#nullable enable` プラグマを追加します。
1. すべての警告に対処します。
1. ライブラリ全体を null 許容対応にするまで、これら最初の 2 つの手順を続けます。
1. *csproj* ファイルに `<Nullable>enable</Nullable>` 要素を追加することにより、プロジェクト全体で null 許容型を有効にします。
1. `#nullable enable` プラグマは不要になったため、削除します。

この 2 番目の戦略は、事前の作業が少なくなります。 トレードオフは、新しいファイルを作成するときの最初のタスクが、プラグマを追加し、それを null 許容対応にすることであるということです。 チームの開発者がそれを忘れた場合、その新しいコードは、すべてのコードを null 許容対応にするという作業が発生します。

どちらの戦略を選択するかは、プロジェクトで行われているアクティブな開発の量によって異なります。 プロジェクトが成熟して安定しているほど、2 番目の戦略がふさわしくなります。 開発中の機能が多いほど、最初の戦略が優れています。

> [!IMPORTANT]
> グローバルな Null 許容コンテキストは、生成されたコード ファイルに適用されません。 いずれの方法でも、Null 許容コンテキストは、生成済みとしてマークされているすべてのソース ファイルに対して "*無効になります*"。 これは、生成されたファイル内のどの API にも注釈が付けられないことを意味します。 ファイルが生成済みとしてマークされる方法は 4 つあります。
>
> 1. .editorconfig で、そのファイルに適用されるセクションで `generated_code = true` を指定します。
> 1. ファイルの先頭にあるコメントに `<auto-generated>` または `<auto-generated/>` を配置します。 これは、コメント内の任意の行に配置できますが、コメント ブロックはファイル内の最初の要素である必要があります。
> 1. ファイル名を *TemporaryGeneratedFile_* で開始します
> 1. ファイル名の末尾を *.designer.cs*、 *.generated.cs*、 *.g.cs*、または *.g.i.cs* にします。
>
> ジェネレーターは、[`#nullable`](language-reference/preprocessor-directives.md#nullable-context) プリプロセッサ ディレクティブを使用してオプトインできます。

## <a name="should-nullable-warnings-introduce-breaking-changes"></a>null 許容の警告によって破壊的変更が発生するか

null 許容参照型を有効にする前は、変数は "*null 許容が認識されていない*" ものと見なされます。 null 許容参照型を有効にすると、そのような変数はすべて "*null 非許容*" になります。 そのような変数が null 以外の値に初期化されていない場合、コンパイラで警告が発生します。

警告が発生する可能性があるもう 1 つの原因は戻り値で、値が初期化されていない場合です。

コンパイラの警告に対処するための最初の手順は、パラメーターと戻り値の型で `?` 注釈を使用して、引数または戻り値が null になる可能性があるときを示すことです。 参照変数が null であってはならないときは、元の宣言が正しくなります。 この作業を行うときの目標は、警告を修正することだけではありません。 より重要な目標は、null 値の可能性があるという意図をコンパイラに理解させることです。 警告を確認すると、ライブラリに関する次の重要な決定がわかります。 設計の意図をより明確に伝えるために、API のシグネチャの変更を検討しますか。 前に調べた `TryGetMessage` メソッドのより優れた API シグネチャは次のようになります。

```csharp
string? TryGetMessage(string key);
```

戻り値は成功または失敗を示し、値が見つかった場合は値を保持します。 多くの場合、API のシグネチャを変更すると、null 値の伝達方法が向上する可能性があります。

ただし、パブリック ライブラリや、ユーザー ベースの大きいライブラリでは、API のシグネチャを変更しない方がよい場合があります。 そのような場合や、他の一般的なパターンでは、属性を適用することで、引数または戻り値が `null` になる可能性がある場合をより明確に定義できます。 API のサーフェイスの変更を検討するかどうかにかかわらず、型の注釈だけでは、引数または戻り値での `null` 値を記述するのに十分ではないことがわかるでしょう。 そのような場合は、属性を適用することで API をより明確に記述できます。

## <a name="attributes-extend-type-annotations"></a>属性で型の注釈を拡張する

変数の null 状態に関する追加情報を表すために、いくつかの属性が追加されました。 C# 8 で null 許容参照型型が導入される前に記述したすべてのコードでは、"*null が認識されません*" でした。 つまり、参照型変数は null である可能性がありますが、null チェックは必須ではありません。 コードが "*null 許容認識*" になると、それらの規則は変わります。 参照型を `null` 値にすることはできません。また、null 許容参照型は、逆参照される前に `null` に対してチェックする必要があります。

API の規則は、`TryGetValue` API シナリオで見たとおり、より複雑になる可能性があります。 多くの API には、変数を `null` にできる場合やできない場合のより複雑な規則があります。 このような場合は、属性を使用してそれらの規則を表します。 API のセマンティクスを記述する属性については、[null 許容の分析に影響を与える属性](./language-reference/attributes/nullable-analysis.md)に関する記事を参照してください。

## <a name="generic-definitions-and-nullability"></a>ジェネリック定義と null 値の許容

ジェネリック型とジェネリック メソッドの null 状態を正しく伝えるには、特別な注意が必要です。 特別な注意が必要になる原因は、null 許容値型と null 許容参照型が根本的に異なるという事実です。 `int?` が `Nullable<int>` のシノニムであるのに対し、`string?` はコンパイラによって追加された属性を持つ `string` です。 結果として、`T` が `class` または `struct` のどちらであるかがわからないと、コンパイラで `T?` の正しいコードを生成できません。

これは、クローズ ジェネリック型の型引数として null 許容型 (値型または参照型) を使用できないという意味ではありません。 `List<string?>` と `List<int?>` はどちらも、`List<T>` の有効なインスタンス化です。

それが意味しているのは、制約なしにジェネリック クラスまたはメソッドの宣言で `T?` を使用することはできない、ということです。 たとえば、<xref:System.Linq.Enumerable.FirstOrDefault%60%601(System.Collections.Generic.IEnumerable%7B%60%600%7D)?displayProperty=nameWithType> は `T?` を返すように変更されません。 この制限を克服するには、`struct` または `class` のいずれかの制約を追加します。 それらの制約のいずれかを指定すると、コンパイラで `T` と `T?` の両方のコードを生成する方法が認識されます。

ジェネリック型引数に使用される型を、null 非許容型に制限することができます。 そのためには、その型引数に `notnull` 制約を追加します。 その制約が適用されているときは、型引数を null 許容型にすることはできません。

## <a name="late-initialized-properties-data-transfer-objects-and-nullability"></a>遅延初期化されるプロパティ、データ転送オブジェクト、および null 値の許容

遅延初期化される (構築後に設定されるという意味です) プロパティの null 値の許容を示す場合、クラスで本来の設計意図が引き続き正しく表現されるよう、特別な配慮が必要になる場合があります。

データ転送オブジェクト (DTO) など、遅延初期化されるプロパティを含む型は、多くの場合、データベース ORM (Object Relational Mapper) のような外部ライブラリ、逆シリアライザー、または別のソースから自動的にプロパティを設定するその他のコンポーネントによってインスタンス化されます。

null 許容参照型を有効にする前に、ある学生を表す次の DTO クラスについて考えてください。

```csharp
class Student
{
    [Required]
    public string FirstName { get; set; }

    [Required]
    public string LastName { get; set; }

    public string VehicleRegistration { get; set; }
}
```

設計の意図 (この例では `Required` 属性によって示されます) として、このシステムでは、`FirstName` および `LastName` プロパティは **必須** であり、したがって null ではないことが示されています。

`VehicleRegistration` プロパティは **必須ではない** ため、null にできます。

null 許容参照型を有効にするときは、本来の意図と一致するように、null 許容にできる DTO のプロパティを指定します。

```csharp
class Student
{
    [Required]
    public string FirstName { get; set; }

    [Required]
    public string LastName { get; set; }

    public string? VehicleRegistration { get; set; }
}
```

この DTO の場合、null にできる唯一のプロパティは ``VehicleRegistration`` です。

ただし、`FirstName` と `LastName` の両方に対しては、null 非許容のプロパティが初期化されていないことを示す警告 `CS8618` がコンパイラによって生成されます。

元の意図が維持されるような方法でコンパイラの警告を解決するために使用できるオプションが 3 つあります。 これらのオプションはいずれも有効です。コーディング スタイルと設計要件に最も適したものを選択する必要があります。

### <a name="initialize-in-the-constructor"></a>コンストラクター内で初期化する

初期化されていないという警告を解決するための最善の方法は、プロパティをコンストラクター内で初期化することです。

```csharp
class Student
{
    public Student(string firstName, string lastName)
    {
        FirstName = firstName;
        LastName = lastName;
    }

    [Required]
    public string FirstName { get; set; }

    [Required]
    public string LastName { get; set; }

    public string? VehicleRegistration { get; set; }
}
```

この方法は、クラスのインスタンスを作成するために使用するライブラリで、コンストラクターにパラメーターを渡すことがサポートされている場合にのみ機能します。

ライブラリでコンストラクターに全部のプロパティではなく "*一部*" だけを渡すことがサポートされている場合があります。 たとえば、EF Core では、通常の列プロパティについての[コンストラクター バインド](/ef/core/modeling/constructors)はサポートされていますが、ナビゲーション プロパティについてはサポートされていません。

クラスのインスタンスを作成するライブラリのドキュメントを調べて、コンストラクター バインドがサポートされている範囲を理解してください。

### <a name="property-with-nullable-backing-field"></a>null 許容バッキング フィールドを持つプロパティ

コンストラクター バインドが機能しない場合、この問題に対処する方法の 1 つは、null 許容バッキング フィールドを持つ null 非許容プロパティを使用することです。

```csharp
private string? _firstName;

[Required]
public string FirstName
{
    set => _firstName = value;
    get => _firstName
           ?? throw new InvalidOperationException("Uninitialized " + nameof(FirstName))
}
```

このシナリオでは、初期化される前の `FirstName` プロパティにアクセスすると、API コントラクトが正しく使用されていないため、コードで `InvalidOperationException` がスローされます。

バッキング フィールドを使用するときは、一部のライブラリに特別な考慮事項があることに注意してください。 たとえば、EF Core は[バッキング フィールド](/ef/core/modeling/backing-field)を正しく使用するように構成することが必要な場合があります。

### <a name="initialize-the-property-to-null"></a>プロパティを null に初期化する

null 許容バッキング フィールドの使用に代わるさらに簡潔な方法として、またはクラスのインスタンスを作成するライブラリがその方法と互換性を持たない場合は、null 免除演算子 (`!`) を使用して、プロパティを `null` に直接初期化できます。

```csharp
[Required]
public string FirstName { get; set; } = null!;

[Required]
public string LastName { get; set; } = null!;

public string? VehicleRegistration { get; set; }
```

適切に初期化される前にプロパティにアクセスするプログラミングのバグの結果の場合を除き、実行時に実際の null 値が観察されることはありません。

## <a name="see-also"></a>関連項目

- [既存のコードベースを null 許容参照に移行する](whats-new/tutorials/upgrade-to-nullable-references.md)
- [EF Core での null 許容参照型の使用](/ef/core/miscellaneous/nullable-reference-types)
