---
title: オブジェクトでパターンを使用する - C# チュートリアル
description: このチュートリアルでは、クラス メンバーでパターン マッチングを使用して、オブジェクトの動作により適したモデルを作成する方法について説明します
ms.date: 11/05/2020
ms.openlocfilehash: 072f6f57696504c2d691473e3a43c1cda53f227f
ms.sourcegitcommit: c7f0beaa2bd66ebca86362ca17d673f7e8256ca6
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/23/2021
ms.locfileid: "104878921"
---
# <a name="use-pattern-matching-to-build-your-class-behavior-for-better-code"></a>パターン マッチングを使用して、より良いコードのためのクラスの動作を構築する

C# のパターン マッチング機能には、アルゴリズムを表すための構文が用意されています。 これらの手法を使用して、クラスの動作を実装できます。 オブジェクト指向のクラス設計と、データ指向の実装を組み合わせることで、現実のオブジェクトをモデル化しながら、簡潔なコードを提供できます。

このチュートリアルで学習する内容は次のとおりです。

> [!div class="checklist"]
>
> - データ パターンを使用して、オブジェクト指向のクラスを表現します。
> - C# のパターン マッチング機能を使用して、それらのパターンを実装します。
> - コンパイラの診断機能を利用して、実装を検証します。

## <a name="prerequisites"></a>前提条件

コンピューターを、C# 9.0 コンパイラが含まれる .NET 5 が実行されるように設定する必要があります。 C# 9.0 コンパイラは、[Visual Studio 2019 バージョン 16.8 プレビュー](https://visualstudio.microsoft.com/vs/preview/)以降または [.NET 5.0 SDK プレビュー](https://dotnet.microsoft.com/download/dotnet/5.0)以降で使用できます。

## <a name="build-a-simulation-of-a-canal-lock"></a>運河の水門のシミュレーションを構築する

このチュートリアルでは、[運河の水門](https://en.wikipedia.org/wiki/Lock_(water_navigation))をシミュレートする C# クラスを構築します。 簡単に言うと、運河の水門は、水面の高さが異なる 2 つの水路の間を通過するときに船を上げ下げする仕組みです。 水門には、2 つのゲートと、水位を変更するためのメカニズムがあります。

通常の操作では、船が一方のゲートから進入するとき、水門の水位は船が進入する側の水位と一致しています。 水門内に入ると、船が水門から出て行く側の水位と一致するように、水位が変更されます。 水位がその側と一致すると、出口側のゲートが開きます。 安全対策により、オペレーターは運河を危険な状態にできないようになっています。 水位は、両方のゲートが閉じられている場合にのみ変更できます。 開くことができるのは最大で 1 つのゲートです。 ゲートを開くには、水門内の水位が、開かれるゲートの外側の水位と一致している必要があります。

この動作をモデル化する C# クラスを構築できます。 `CanalLock` クラスにより、いずれかのゲートを開いたり閉じたりするコマンドがサポートされます。 他に、水を上げ下げするためのコマンドがあります。 また、このクラスにより、両方のゲートと水位の現在の状態を読み取るためのプロパティもサポートされる必要があります。 これらのメソッドにより安全対策を実装します。

## <a name="define-a-class"></a>クラスを定義する

`CanalLock` クラスをテストするコンソール アプリケーションを作成します。 Visual Studio または .NET CLI を使用して、.NET 5 用の新しいコンソール プロジェクトを作成します。 次に、新しいクラスを追加し、`CanalLock` という名前を指定します。 次に、パブリック API を設計しますが、メソッドは実装しないでおきます。

:::code language="csharp" source="snippets/pattern-objects/InterimSteps.cs" ID="APIDesign":::

上のコードにより、両方のゲートが閉じていて、水位が低になるように、オブジェクトが初期化されます。 次に、クラスの最初の実装を作成するときのガイドにするため、`Main` メソッドに次のテスト コードを記述します。

:::code language="csharp" source="snippets/pattern-objects/Program.cs" ID="HappyTests":::

次に、`CanalLock` クラスの各メソッドの最初の実装を追加します。 次のコードにより、安全ルールが考慮されていないクラスのメソッドが実装されます。 安全テストは後で追加します。

:::code language="csharp" source="snippets/pattern-objects/InterimSteps.cs" ID="FirstImplementation":::

これまでに記述したテストは合格です。 基本が実装されました。 次に、最初のエラー条件のテストを記述します。 前のテストの終了時点では、両方のゲートは閉じられ、水位は低に設定されています。 上の側のゲートを開こうとするテストを追加します。

:::code language="csharp" source="snippets/pattern-objects/Program.cs" ID="HighGateSafetyTest":::

ゲートが開くため、このテストは失敗します。 最初の実装として、次のコードを使用して修正できます。

:::code language="csharp" source="snippets/pattern-objects/InterimSteps.cs" ID="SecondImplementation":::

テストは合格します。 しかし、さらにテストを追加していくと、`if` 句がどんどん増え、異なるプロパティをテストするようになります。 やがて、メソッドが複雑すぎて、条件を追加できなくなります。

## <a name="implement-the-commands-with-patterns"></a>パターンを使用してコマンドを実装する

もっとよい方法は、"*パターン*" を使用して、オブジェクトがコマンドを実行するための有効な状態であるかどうかを判断することです。 次の 3 つの変数の関数として、コマンドが許可されるかどうかを表すことができます: ゲートの状態、水位、新しい設定。

| 新しい設定 | ゲートの状態 | 水位 | 結果             |
| ----------- | ---------- | ----------- | ------------------ |
| ［不可］      | ［不可］     | 高        | ［不可］             |
| ［不可］      | ［不可］     | 低         | ［不可］             |
| ［不可］      | 開く       | 高        | 開く               |
| ~~解決済み~~  | ~~[ファイル]~~   | ~~低~~     | ~~解決済み~~         |
| 開く        | 解決済み     | 高        | 開く               |
| 開く        | 解決済み     | 低         | 閉 (エラー)     |
| 開く        | 開く       | 高        | 開く               |
| ~~[ファイル]~~    | ~~[ファイル]~~   | ~~低~~     | ~~閉 (エラー)~~ |

表の 4 番目と最後の行は無効であるため、テキストを消してあります。 ここで追加しようとしているコードを使用して、水位が低いときは、高い水位のゲートが開かれないようにする必要があります。  それらの状態は、1 つの switch 式としてコーディングできます (`false` は "閉" を示すことに注意してください)。

:::code language="csharp" source="snippets/pattern-objects/InterimSteps.cs" ID="ThirdImplementation":::

このバージョンを試してみます。 テストは合格し、コードが検証されました。 完全な表には、入力と結果の可能な組み合わせが示されています。 これは、自分や他の開発者が表をすばやく見て、可能なすべての入力が網羅されていることを確認できることを意味します。 さらに簡単にするには、コンパイラも役に立ちます。 前のコードを追加した後、コンパイラによって警告が生成されることがあります。*CS8524* は、switch 式ですべての可能な入力がカバーされていないことを示します。 その警告が表示される原因は、入力の 1 つが `enum` 型であることです。 コンパイラでは、"可能なすべての入力" は、基になる型からのすべての入力 (通常は `int`) と解釈されます。 この `switch` 式の場合、`enum` で宣言されている値のみがチェックされています。 警告を除去するには、式の最後のアームに、キャッチオール破棄パターンを追加します。 この状態は無効な入力を示すため、例外をスローします。

```csharp
_  => throw new InvalidOperationException("Invalid internal state"),
```

前記の switch アームは、すべての入力に一致するため、`switch` 式の最後に置く必要があります。 前の方の順序に移動して実験します。 そのようにすると、パターン内に到達できないコードがあることを示すコンパイラ エラー *CS8510* が発生します。  switch 式の自然な構造により、コンパイラはエラーや警告を生成して間違いを防ぐことができます。 コンパイラの "セーフティ ネット" により、少ない繰り返しで正しいコードをより簡単に作成でき、switch アームとワイルドカードを自由に組み合わせることができます。 組み合わせによって意図せず到達できないアームが作成されると、コンパイラによってエラーが表示され、必要なアームを削除すると警告が表示されます。

最初の変更は、コマンドによってゲートが閉じられるすべてのアームを結合することです。これは常に許可されます。 次のコードを switch 式の最初のアームとして追加します。

```csharp
(false, _, _) => false,
```

前の switch アームを追加すると、4 つのコンパイラ エラーが発生します。コマンドが `false` であるアームごとに 1 つあります。 それらのアームは、新しく追加したアームによって既にカバーされています。 それら 4 つの行は安全に削除できます。 この新しい switch アームを使用して、それらの条件を置き換えます。

次に、ゲートを開くコマンドの 4 つのアームを簡略化できます。 水位が高であるどちらの場合も、ゲートを開くことができます。 (1 つでは既に開いています)。水位が低である 1 つのケースでは例外がスローされ、もう 1 つのケースでは発生しません。 水門が既に無効な状態である場合は、同じ例外がスローされても安全である必要があります。 それらのアームは、次のように簡略化できます。

```csharp
(true, _, WaterLevel.High) => true,
(true, false, WaterLevel.Low) => throw new InvalidOperationException("Cannot open high gate when the water is low"),
_ => throw new InvalidOperationException("Invalid internal state"),
```

テストを再び実行すると、それらは合格します。 `SetHighGate` メソッドの最終バージョンは次のようになります。

:::code language="csharp" source="snippets/pattern-objects/CanalLock.cs" ID="FinalImplementaton":::

## <a name="implement-patterns-yourself"></a>パターンを自分で実装する

これで手法を確認できたので、`SetLowGate` メソッドと `SetWaterLevel` メソッドについては自分で入力してください。  まず、次のコードを追加して、それらのメソッドでの無効な操作をテストします。

:::code language="csharp" source="snippets/pattern-objects/Program.cs" ID="FinalTestCode":::

アプリケーションをもう一度実行します。 新しいテストは失敗し、運河の水門が無効な状態になることを確認できます。 残りのメソッドを自分で実装してみてください。 低い方のゲートを設定するメソッドは、高い方のゲートを設定するメソッドに似ているはずです。 水位を変更するメソッドのチェックは異なりますが、同様の構造にする必要があります。 水位を設定するメソッドにも同じプロセスを使用すると便利な場合があります。 次の 4 つのすべての入力から始めます: 両方のゲートの状態、水位の現在の状態、要求された新しい水位。 switch 式の先頭は次のようになります。

```csharp
CanalLockWaterLevel = (newLevel, CanalLockWaterLevel, LowWaterGateOpen, HighWaterGateOpen) switch
{
    // elided
};
```

全部で 16 個の switch アームを使用します。 その後、テストと簡略化を行います。

次のようなメソッドができましたか。

:::code language="csharp" source="snippets/pattern-objects/CanalLock.cs" ID="FinalExercise":::

テストは合格し、運河の水門は安全に作動するはずです。

## <a name="summary"></a>まとめ

このチュートリアルでは、パターン マッチングを使用して、オブジェクトの内部状態に変更を適用する前に、その状態を確認する方法について学習しました。 プロパティの組み合わせを確認できます。 それらの遷移のいずれかの表を作成したら、コードをテストして、読みやすさと保守性のために簡素化できます。 これらの初期リファクタリングにより、内部状態を検証したり、他の API 変更を管理したりするリファクタリングがさらに提案される場合があります。 このチュートリアルでは、クラスとオブジェクトを、よりデータ指向でパターンベースのアプローチと組み合わせて、それらのクラスを実装しました。
