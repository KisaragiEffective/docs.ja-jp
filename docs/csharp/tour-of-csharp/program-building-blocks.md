---
title: C# プログラムの構成要素
description: C# メンバー、式、およびステートメントについて説明します。 型には、作成するメンバーが含まれます。 これらのメンバーは、ステートメントおよび式から構築されます。
ms.date: 08/06/2020
ms.openlocfilehash: 79ba391a6c4c6dc453f6c6e07107e4dd831e111d
ms.sourcegitcommit: f0fc5db7bcbf212e46933e9cf2d555bb82666141
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 02/17/2021
ms.locfileid: "100582957"
---
# <a name="program-building-blocks"></a>プログラムの構成要素

前の記事で説明した型は、次の構成要素を使用して構築されています: ["***メンバー** _"](../programming-guide/classes-and-structs/members.md)、["_*_式_*_"、"_ *_ステートメント_**"](../programming-guide/statements-expressions-operators/index.md)。

## <a name="members"></a>メンバー

`class` のメンバーは、"***静的メンバー** _" または "_*_インスタンス メンバー_**" です。 静的メンバーはクラスに属しており、インスタンス メンバーはオブジェクト (クラスのインスタンス) に属しています。

クラスに格納できるメンバーの種類の概要を次の一覧に示します。

- **定数**: クラスに関連付けられている定数値
- **フィールド**: クラスに関連付けられている変数
- **メソッド**: クラスによって実行可能なアクション
- **[プロパティ]** :クラスの名前付きプロパティの読み取りと書き込みに関連付けられているアクション
- **インデクサー**: 配列など、クラスのインスタンスのインデックス作成に関連付けられているアクション
- **イベント**:クラスによって生成可能な通知
- **演算子**: クラスによってサポートされている変換と式の演算子
- **コンストラクター**: クラスのインスタンスまたはクラス自体を初期化するために必要なアクション
- **ファイナライザー**: クラスのインスタンスが完全に破棄される前に実行されるアクション
- **型**: クラスで宣言される、入れ子にされた型

## <a name="accessibility"></a>ユーザー補助

クラスの各メンバーにはアクセシビリティが関連付けられています。アクセシビリティにより、メンバーへのアクセスが可能なプログラムのテキストの範囲が制御されます。 アクセシビリティには 6 つの有効な形式があります。 アクセス修飾子の概要を次に示します。

- `public`:アクセスは制限されません。
- `private`:アクセスはこのクラスに制限されます。
- `protected`:アクセスは、このクラスまたはこのクラスから派生したクラスに制限されます。
- `internal`: 現在のアセンブリ (`.exe` または `.dll`) にアクセスが制限されます。
- `protected internal`: アクセスは、このクラス、このクラスから派生したクラス、または同じアセンブリ内のクラスに制限されます。
- `private protected`: アクセスは、このクラスまたは同じアセンブリ内のこの型から派生されたクラスに制限されます。

## <a name="fields"></a>フィールド

"*フィールド*" は、クラスまたはクラスのインスタンスに関連付けられている変数です。

static 修飾子で宣言されているフィールドは、静的フィールドを定義します。 静的フィールドは、格納場所を 1 つだけ識別します。 クラスのインスタンスがいくつ作成されても、静的フィールドのコピーは 1 つだけです。

static 修飾子なしで宣言されているフィールドは、インスタンス フィールドを定義します。 クラスの各インスタンスには、そのクラスのすべてのインスタンス フィールドの個別のコピーが含まれています。

次の例では、`Color` クラスの各インスタンスに、インスタンス フィールド `R`、`G`、`B` の個別のコピーが含まれていますが、静的フィールド `Black`、`White`、`Red`、`Green`、`Blue` のコピーは 1 つだけです。

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="ColorClassDefinition":::

前述の例のように、`readonly` 修飾子を使用して "*読み取り専用フィールド*" を宣言できます。 読み取り専用フィールドへの割り当ては、フィールドの宣言の一部として、または同じクラスのコンストラクター内でのみ可能です。

## <a name="methods"></a>メソッド

"*メソッド*" は、オブジェクトまたはクラスによって実行可能な計算またはアクションを実装するメンバーです。 "*静的メソッド*" にはクラスを通じてアクセスします。 "*インスタンス メソッド*" にはクラスのインスタンスを通じてアクセスします。

メソッドには、メソッドに渡される値または変数参照を表す "*パラメーター*" の一覧が含まれている場合があります。 メソッドには、メソッドによって計算され返される値の型を指定する "*戻り値の型*" が含まれます。 メソッドによって値が返されない場合、メソッドの戻り値の型は `void` です。

型と同様に、メソッドには型パラメーターのセットを含めることができます。その場合、メソッドの呼び出し時に型引数を指定する必要があります。 型引数は、型とは異なり、多くの場合メソッド呼び出しの引数から推論できます。型引数を明示的に指定する必要はありません。

メソッドの "*シグネチャ*" は、メソッドが宣言されているクラス内で一意である必要があります。 メソッドのシグネチャは、メソッドの名前と、型パラメーターの数と、そのパラメーターの数、修飾子、および型とで構成されます。 メソッドのシグネチャに戻り値の型は含まれません。

メソッド本体が単一の式である場合は、次の例に示すように、コンパクトな式形式を使用してメソッドを定義できます。

```csharp
public override string ToString() => "This is an object";
```

### <a name="parameters"></a>パラメーター

パラメーターは、値または変数参照をメソッドに渡すために使用されます。 メソッドのパラメーターは、メソッドの呼び出し時に指定する "*引数*" から実際の値を取得します。 値パラメーター、参照パラメーター、出力パラメーター、およびパラメーター配列の 4 種類のパラメーターがあります。

"*値パラメーター*" は、入力引数を渡すために使われます。 値パラメーターは、パラメーターに渡された引数からその初期値を取得するローカル変数に相当します。 値パラメーターに対する変更は、パラメーターに渡された引数には影響を与えません。

値パラメーターは省略可能であり、既定値を指定すると、対応する引数を省略できます。

"*参照パラメーター*" は、参照によって引数を渡すために使われます。 参照パラメーターに渡される引数は、明確な値を持つ変数である必要があります。 メソッドの実行中に、参照パラメーターは引数の変数と同じ格納場所を表します。 参照パラメーターは、`ref` 修飾子で宣言されます。 `ref` パラメーターの使用例を次に示します。

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="RefExample":::

"*出力パラメーター*" は、参照によって引数を渡すために使われます。 参照パラメーターに似ていますが、呼び出し元が提供する引数に値を明示的に割り当てる必要がない点が異なります。 出力パラメーターは、`out` 修飾子で宣言されます。 次の例では、C# 7 で導入された構文を使っている `out` パラメーターを示します。

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="OutExample":::

"*パラメーター配列*" は、引数の変数の数をメソッドに渡せるようにします。 パラメーター配列は、`params` 修飾子で宣言されます。 パラメーター配列として使用できるのは、メソッドの最後のパラメーターのみです。パラメーター配列の型は、1 次元配列の型である必要があります。 <xref:System.Console?displayProperty=nameWithType> クラスの `Write` および `WriteLine` メソッドは、パラメーター配列の使用方法の好例です。 これらのメソッドは次のように宣言されます。

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="ConsoleExtract":::

パラメーター配列を使用するメソッド内では、パラメーター配列は、配列型の通常のパラメーターとまったく同じように動作します。 ただし、パラメーター配列を使用するメソッドの呼び出しでは、パラメーター配列の型の 1 つの引数またはパラメーター配列の要素型の任意の数の引数を渡すことができます。 後者の場合、配列インスタンスが自動的に作成され、指定した引数を使用して初期化されます。 次のような例があるとします。

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="UseParamsArgs":::

これは、次の記述と同じです。

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="CompilerParams":::

### <a name="method-body-and-local-variables"></a>メソッドの本体とローカル変数

メソッドの本体では、メソッドの呼び出し時に実行するステートメントを指定します。

メソッドの本体は、メソッドの呼び出しに固有の変数を宣言できます。 このような変数は "*ローカル変数*" と呼ばれます。 ローカル変数宣言は、型名、変数名、および (場合によっては) 初期値を指定します。 次の例では、初期値 0 を使用してローカル変数 `i` を宣言し、初期値を使用せずにローカル変数 `j` を宣言します。

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="SquaresClass":::

C# では、ローカル変数の値を取得する前に、ローカル変数を "*明示的に割り当てる*" 必要があります。 たとえば、前述の `i` の宣言に初期値が含まれていなかった場合、コンパイラによって後での `i` の使用に対するエラーが報告されます。これは、プログラム内のそれらのポイントで `i` が明示的に割り当てられていないためです。

メソッドでは、`return` ステートメントを使用して、呼び出し元に制御を戻すことができます。 `void` を返すメソッドの場合、`return` ステートメントでは式を指定できません。 void 以外を返すメソッドの場合、`return` ステートメントは戻り値を計算する式を含める必要があります。

### <a name="static-and-instance-methods"></a>静的メソッドとインスタンス メソッド

`static` 修飾子で宣言されているメソッドは "*静的メソッド*" です。 静的メソッドは、特定のインスタンスでは動作せず、静的メンバーにのみ直接アクセスできます。

`static` 修飾子なしで宣言されているメソッドは "*インスタンス メソッド*" です。 インスタンス メソッドは、特定のインスタンスで動作し、静的メンバーとインスタンス メンバーの両方にアクセスできます。 インスタンス メソッドが呼び出されたインスタンスには、`this` として明示的にアクセスできます。 静的メソッドで `this` を参照するとエラーになります。

次の `Entity` クラスには、静的メンバーとインスタンス メンバーの両方があります。

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="EntityClass":::

各 `Entity` インスタンスには、シリアル番号 (およびここに表示されていないその他の情報) が含まれています。 `Entity` コンストラクターは (インスタンス メソッドと同様に)、次に使用可能なシリアル番号を持つ新しいインスタンスを初期化します。 コンストラクターはインスタンス メンバーであるため、`_serialNo` インスタンス フィールドと `s_nextSerialNo` 静的フィールドの両方にアクセスできます。

静的メソッドである `GetNextSerialNo` と `SetNextSerialNo` は `s_nextSerialNo` 静的フィールドにアクセスできますが、`_serialNo` インスタンス フィールドに直接アクセスするとエラーになります。

`Entity` クラスの使用例を次に示します。

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="UsingEntity":::

静的メソッドである `SetNextSerialNo` と `GetNextSerialNo` はクラスで呼び出されますが、`GetSerialNo` インスタンス メソッドはクラスのインスタンスで呼び出されます。

### <a name="virtual-override-and-abstract-methods"></a>仮想メソッド、オーバーライド メソッド、および抽象メソッド

インスタンス メソッドの宣言に `virtual` 修飾子が含まれている場合、そのメソッドは "*仮想メソッド*" と呼ばれます。 virtual 修飾子が存在しない場合、そのメソッドは "*非仮想メソッド*" と呼ばれます。

仮想メソッドが呼び出されると、その呼び出しが行われるインスタンスの "*実行時の型*" によって、呼び出す実際のメソッドの実装が決定します。 非仮想メソッドの呼び出しでは、インスタンスの "*コンパイル時の型*" が決定要因です。

仮想メソッドは派生クラスで "*オーバーライド*" できます。 インスタンス メソッドの宣言に override 修飾子が含まれている場合、メソッドは、同じシグネチャを持つ継承された仮想メソッドをオーバーライドします。 仮想メソッドの宣言には新しいメソッドが導入されています。 オーバーライド メソッドの宣言では、そのメソッドの新しい実装を提供することで既存の継承された仮想メソッドを特殊化します。

"*抽象メソッド*" は、実装のない仮想メソッドです。 抽象メソッドは `abstract` 修飾子を使用して宣言され、抽象クラス内でのみ許可されます。 抽象メソッドは、すべての非抽象派生クラスでオーバーライドする必要があります。

次の例では、式ツリー ノードを表す抽象クラス `Expression`、および定数、変数参照、算術演算の式ツリー ノードを実装する 3 つの派生クラス `Constant`、`VariableReference`、`Operation` を宣言します  (この例は、式ツリー型に似ていますが、関連はありません)。

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="WorkingWithExpressions":::

前述の 4 つのクラスは、算術式をモデル化するために使用できます。 たとえば、これらのクラスのインスタンスを使用して、式 `x + 3` を次のように表すことができます。

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="UseExpressions":::

`Expression` インスタンスの `Evaluate` メソッドが呼び出され、指定された式を評価して `double` 値を生成します。 このメソッドは、変数の名前 (エントリのキーとして) と値 (エントリの値として) が格納されている `Dictionary` 引数を受け取ります。 `Evaluate` は抽象メソッドなので、`Expression` から派生した非抽象クラスでは、`Evaluate` をオーバーライドする必要があります。

`Evaluate` の `Constant` の実装は、格納された定数を単に返します。 `VariableReference` の実装は、ディクショナリで変数名を検索し、結果の値を返します。 `Operation` の実装は、(`Evaluate` メソッドを再帰的に呼び出すことによって) まず左と右のオペランドを評価し、指定された算術演算を実行します。

次のプログラムでは、`Expression` クラスを使用して、式 `x * (y + 2)` の異なる値の `x` と `y` を評価します。

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="UsingExpressions":::

### <a name="method-overloading"></a>メソッドのオーバーロード

メソッドの "*オーバーロード*" では、メソッドのシグネチャが一意であれば、同じクラス内の複数のメソッドに同じ名前を付けることができます。 オーバーロードされたメソッドの呼び出しをコンパイルする場合、コンパイラは "*オーバーロードの解決*" を使用して、呼び出すメソッドを決定します。 オーバーロードの解決では、引数に最適なメソッドが 1 つ検索されます。 最適な一致が 1 つも見つからない場合は、エラーが報告されます。 次の例は、オーバーロードの解決が有効な場合を示しています。 `UsageExample` メソッド内の各呼び出しのコメントは、呼び出されるメソッドを示しています。

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="Overloading":::

この例に示すように、引数をパラメーターの厳密な型および型引数に明示的にキャストすることにより、特定のメソッドを常に選択できます。

## <a name="other-function-members"></a>その他の関数メンバー

実行可能コードが含まれるメンバーは、クラスの "*関数メンバー*" と総称されます。 前のセクションでは、関数メンバーの主な種類であるメソッドについて説明しました。 ここでは、C# でサポートされるその他の種類の関数メンバー (コンストラクター、プロパティ、インデクサー、イベント、演算子、およびファイナライザー) について説明します。

次の例では、オブジェクトの拡張可能なリストを実装する、`MyList<T>` と呼ばれるジェネリック クラスを示します。 このクラスには、最も一般的な種類の関数メンバーの例がいくつか含まれています。

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="ListExample":::

### <a name="constructors"></a>コンストラクター

C# は、インスタンス コンストラクターと静的コンストラクターの両方をサポートします。 "*インスタンス コンストラクター*" は、クラスのインスタンスを初期化するために必要なアクションを実装するメンバーです。 "*静的コンストラクター*" は、クラスを最初に読み込むときに、そのクラス自体を初期化するために必要なアクションを実装するメンバーです。

コンストラクターは、戻り値の型がなく、含んでいるクラスと同じ名前を持つメソッドのように宣言されます。 コンストラクターの宣言に `static` 修飾子が含まれている場合は、静的コンストラクターが宣言されます。 それ以外の場合は、インスタンス コンストラクターが宣言されます。

インスタンス コンストラクターはオーバーロード可能であり、省略可能なパラメーターを指定できます。 たとえば、`MyList<T>` クラスでは、1 つの省略可能な `int` パラメータ―を伴う 1 つのインスタンス コンストラクターを宣言します。 インスタンス コンストラクターは、`new` 演算子を使用して呼び出されます。 次のステートメントは、`MyList` クラスのコンストラクターを使用して、2 つの `MyList<string>` インスタンスを割り当てます (省略可能な引数を使用した場合と使用していない場合の両方を示します)。

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="CreateLists":::

他のメンバーとは異なり、インスタンス コンストラクターは継承されません。 クラスには、そのクラス内で実際に宣言されたコンストラクター以外のインスタンス コンストラクターはありません。 クラスのインスタンス コンストラクターが指定されていない場合は、パラメーターなしの空のコンストラクターが自動的に指定されます。

### <a name="properties"></a>プロパティ

"*プロパティ*" は、フィールドが自然に拡張したものです。 フィールドとプロパティはどちらも型が関連付けられている名前付きのメンバーであり、それらにアクセスするための構文は同じです。 ただし、フィールドとは異なり、プロパティは格納場所を表しません。 その代わりに、プロパティには、値の読み取りまたは書き込みの際に実行されるステートメントを指定する "*アクセサー*" があります。

プロパティはフィールドのように宣言されますが、宣言はセミコロンで終わるのではなく、区切り記号 `{` と `}` の間に記述する get アクセサーまたは set アクセサーで終わる点が異なります。 get アクセサーと set アクセサーの両方があるプロパティは、"*読み取り/書き込みプロパティ*" です。 get アクセサーのみがあるプロパティは、"*読み取り専用*" プロパティです。 set アクセサーのみがあるプロパティは、"*書き込み専用*" プロパティです。

get アクセサーは、プロパティの型の戻り値を持つパラメーターなしのメソッドに相当します。 set アクセサーは、1 つのパラメーターの名前付きの値を持ち、戻り値の型を持たないメソッドに相当します。 get アクセサーは、プロパティの値を計算します。 set アクセサーは、プロパティの新しい値を提供します。 プロパティが代入のターゲットである場合、あるいは `++` または `--` のオペランドである場合は、set アクセサーが呼び出されます。 プロパティが参照されるその他のケースでは、get アクセサーが呼び出されます。

`MyList<T>` クラスは 2 つのプロパティ (`Count` と `Capacity`) を宣言します。これらは、それぞれ読み取り専用プロパティと読み取り/書き込みプロパティです。 次のコードは、これらのプロパティの使用例です。

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="AccessProperties":::

フィールドおよびメソッドと同様に、C# はインスタンス プロパティと静的プロパティの両方をサポートします。 静的プロパティは static 修飾子で宣言され、インスタンス プロパティは修飾子なしで宣言されます。

プロパティのアクセサーは仮想にすることができます。 プロパティの宣言に `virtual`、`abstract`、または `override` の各修飾子が含まれている場合、その宣言はプロパティのアクセサーに適用されます。

### <a name="indexers"></a>インデクサー

"*インデクサー*" は、配列と同じ方法でオブジェクトのインデックスを作成できるようにするメンバーです。 インデクサーはプロパティのように宣言されますが、メンバーの名前が、`this` の後に区切り記号 `[` と `]` でパラメーター リストを囲んだものになる点が異なります。 パラメーターは、インデクサーのアクセサーで使用できます。 プロパティと同様に、読み取り/書き込み、読み取り専用、および書き込み専用のインデクサーを使用できます。また、インデクサーのアクセサーを仮想にすることができます。

`MyList<T>` クラスは、`int` パラメーターを受け取る 1 つの読み取り/書き込みインデクサーを宣言します。 インデクサーを使用すると、`int` 値を持つ `MyList<T>` インスタンスのインデックスを作成できます。 次に例を示します。

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="ListAccess":::

インデクサーはオーバーロードすることができます。 パラメーターの数または型が異なる限り、クラスでは複数のインデクサーを宣言できます。

### <a name="events"></a>events

"*イベント*" は、クラスまたはオブジェクトで通知を提供できるようにするメンバーです。 イベントはフィールドのように宣言されますが、`event` キーワードが宣言に含まれており、型がデリゲート型でなければならない点が異なります。

イベント メンバーを宣言するクラス内では、イベントはデリゲート型のフィールドと同じように動作します (イベントが抽象イベントでなく、アクセサーを宣言しない場合)。 フィールドは、イベントに追加されたイベント ハンドラーを表すデリゲートへの参照を格納します。 イベント ハンドラーが存在しない場合、フィールドは `null` です。

`MyList<T>` クラスは、`Changed` という 1 つのイベント メンバーを宣言します。このメンバーは新しい項目がリストに追加されたことを示します。 Changed イベントは `OnChanged` 仮想メソッドによって発生します。このメソッドは、最初にイベントが `null` であるかどうか (ハンドラーが存在しないこと) を確認します。 イベントを発生させるという概念は、イベントによって表されるデリゲートの呼び出しとまったく同じです。 イベントを発生させるための特殊な言語コンストラクトはありません。

クライアントは、"*イベント ハンドラー*" を使用してイベントに対応します。 イベント ハンドラーは、`+=` 演算子を使用してアタッチされ、`-=` 演算子を使用して削除されます。 次の例では、`MyList<string>` の `Changed` イベントにイベント ハンドラーをアタッチします。

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="RespondToEvents":::

イベントの基になる記憶域の制御が求められる高度なシナリオでは、イベントの宣言で `add` アクセサーと `remove` アクセサーを明示的に指定できます。これらは、プロパティの `set` アクセサーに似ています。

### <a name="operators"></a>オペレーター

"*演算子*" は、クラスのインスタンスに特定の式の演算子を適用する意味を定義するメンバーです。 単項演算子、2 項演算子、および変換演算子の 3 種類を定義できます。 すべての演算子は `public` および `static` として宣言する必要があります。

`MyList<T>` クラスでは、`operator ==` と `operator !=` の 2 つの演算子を宣言します。 これらのオーバーライドされた演算子は、これらの演算子を `MyList` インスタンスに適用する式に新しい意味を与えます。 具体的には、`Equals` メソッドを使用して含まれている各オブジェクトを比較する際に、演算子が 2 つの `MyList<T>` インスタンスの等価性を定義します。 次の例では、`==` 演算子を使用して 2 つの `MyList<int>` インスタンスを比較します。

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="ListAddition":::

最初の `Console.WriteLine` は `True` を出力します。これは、2 つのリストに、同じ値を持つ同じ数のオブジェクトが同じ順序で含まれているためです。 `MyList<T>` で `operator ==` が定義されていない場合は、`a` と `b` が異なる `MyList<int>` インスタンスを参照するため、最初の `Console.WriteLine` は `False` を出力します。

### <a name="finalizers"></a>ファイナライザー

"*ファイナライザー*" は、クラスのインスタンスを最終処理するために必要なアクションを実装するメンバーです。 通常、アンマネージド リソースを解放するにはファイナライザーが必要です。 ファイナライザーではパラメーターとアクセシビリティ修飾子を使用できません。また、ファイナライザーを明示的に呼び出すことはできません。 インスタンスのファイナライザーは、ガベージ コレクション中に自動的に呼び出されます。 詳細については、[ファイナライザー](../programming-guide/classes-and-structs/destructors.md)に関する記事を参照してください。

ガベージ コレクターは、オブジェクトを収集してファイナライザーを実行するタイミングを決定する際に広く許容されます。 具体的には、ファイナライザーの呼び出しのタイミングは確定的ではなく、ファイナライザーは任意のスレッドで実行される可能性があります。 これらの理由およびそれ以外の理由のため、他のソリューションが実現できない場合にのみ、クラスはファイナライザーを実装する必要があります。

`using` ステートメントは、オブジェクトを破棄するためのより適切な方法を提供します。

## <a name="expressions"></a>式

"*式*" は "*オペランド*" と "*演算子*" で構成されます。 式の演算子は、オペランドに適用する演算を表します。 演算子の例として、`+`、`-`、`*`、`/`、および `new` などがあります。 オペランドの例としては、リテラル、フィールド、ローカル変数、式などがあります。

式に複数の演算子が含まれている場合、演算子の "*優先順位*" によって、個々の演算子を評価する順序が制御されます。 たとえば、式 `x + y * z` の評価は `x + (y * z)` ですが、これは `*` 演算子が `+` 演算子より高い優先順位だからです。

1 つのオペランドが同じ優先順位を持つ 2 つの演算子の間で発生した場合、演算子の *結合性* によって演算が実行される順序が決定されます。

* 代入演算子および null 合体演算子を除くすべてのバイナリ演算子は、"*左からの結合*"、つまり演算は左から右に実行されます。 たとえば、`x + y + z` は `(x + y) + z` と評価されます。
* 代入演算子、null 合体 `??` および `??=` 演算子、および条件演算子 `?:` は、"*右からの結合*"、つまり演算は右から左に実行されます。 たとえば、`x = y = z` は `x = (y = z)` と評価されます。

優先順位と結合性は、かっこを使用して制御することができます。 たとえば、`x + y * z` は最初に `y` と `z` を掛け、そして結果を `x` に足しますが、`(x + y) * z` では最初に `x` と `y` を足してから `z` を掛けます。

ほとんどの演算子は [*オーバーロード*](../language-reference/operators/operator-overloading.md)できます。 演算子をオーバーロードすると、ユーザー定義演算子の実装を、1 つまたは両方のオペランドがユーザー定義のクラスまたは構造体型である演算子に指定することができます。

C# では、[算術](../language-reference/operators/arithmetic-operators.md)、[論理](../language-reference/operators/boolean-logical-operators.md)、[ビットごとやシフト](../language-reference/operators/bitwise-and-shift-operators.md)の演算に加えて、[等値](../language-reference/operators/equality-operators.md)や[順序](../language-reference/operators/comparison-operators.md)の比較を実行するための多数の演算子を提供しています。

優先度順に並べられた C# 演算子の完全な一覧については、「[C# 演算子](../language-reference/operators/index.md)」を参照してください。

## <a name="statements"></a>ステートメント

プログラムの処理は、"*ステートメント*" を使用して表されます。 C# はさまざまな種類のステートメントをサポートしており、その多くは埋め込みステートメントとして定義されています。

- "*ブロック*" を使用すると、1 つのステートメントしか使用できないコンテキストで複数のステートメントを記述できます。 ブロックは、区切り記号 `{` と `}` の間に記述されたステートメントのリストから成ります。
- "*宣言ステートメント*" は、ローカル変数および定数の宣言に使用します。
- "*式ステートメント*" は、式の評価に使用します。 ステートメントとして使用できる式には、メソッドの呼び出し、`new` 演算子を使用したオブジェクトの割り当て、`=` 演算子と複合代入演算子を使用した代入、`++` 演算子と `--` 演算子を使用したインクリメント演算とデクリメント演算、および `await` 式があります。
- "*選択ステートメント*" は、式の値に基づいて、実行できる多数のステートメントから 1 つを選択するために使用します。 このグループには、`if` および `switch` ステートメントが含まれています。
- "*繰り返しステートメント*" は、埋め込みステートメントを繰り返し実行するために使用します。 このグループには、`while`、`do`、`for`、および `foreach` ステートメントが含まれています。
- "*ジャンプ ステートメント*" は、制御を移すために使用します。 このグループには、`break`、`continue`、`goto`、`throw`、`return`、および `yield` ステートメントが含まれています。
- `try`...`catch` ステートメントはブロックの実行中に発生した例外をキャッチするために使用し、`try`...`finally` ステートメントは例外が発生したかどうかにかかわらず常に実行される終了処理コードを指定するために使用します。
- `checked` および `unchecked` ステートメントは、整数型の算術演算および変換に対するオーバーフロー チェック コンテキストを制御するために使用します。
- `lock` ステートメントは、指定のオブジェクトに対する相互排他ロックを取得し、ステートメントを実行してからロックを解放するために使用します。
- `using` ステートメントは、リソースを取得し、ステートメントを実行してからそのリソースを破棄するために使用します。

使用できるステートメントの種類を次に示します。

* ローカル変数の宣言。
* ローカル定数の宣言。
* 式ステートメント。
* `if` ステートメント。
* `switch` ステートメント。
* `while` ステートメント。
* `do` ステートメント。
* `for` ステートメント。
* `foreach` ステートメント。
* `break` ステートメント。
* `continue` ステートメント。
* `goto` ステートメント。
* `return` ステートメント。
* `yield` ステートメント。
* `throw` ステートメントと `try` ステートメント。
* `checked` および `unchecked` ステートメント。
* `lock` ステートメント。
* `using` ステートメント。

>[!div class="step-by-step"]
>[前へ](types.md)
>[次へ](features.md)
