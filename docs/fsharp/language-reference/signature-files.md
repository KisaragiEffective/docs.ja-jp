---
title: シグネチャ ファイル
description: F# シグネチャ ファイルを使用して、型、名前空間、モジュールなど F# プログラムの一連の要素のパブリック シグネチャに関する情報を保持する方法について説明します。
ms.date: 06/15/2018
ms.openlocfilehash: c04ac8bf4ee360a2caa15be8f2bbea41105bd160
ms.sourcegitcommit: f20dd18dbcf2275513281f5d9ad7ece6a62644b4
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 07/30/2019
ms.locfileid: "68627152"
---
# <a name="signatures"></a>シグネチャ

シグネチャ ファイルには、型、名前空間、モジュールなど F# プログラムの一連の要素のパブリック シグネチャに関する情報が含まれています。 これらのプログラム要素のアクセシビリティを指定するために使用できます。

## <a name="remarks"></a>解説

それぞれの F# コード ファイルでは、 *シグネチャ ファイル*(.fs の代わりに .fsi の拡張子を持つ、コード ファイルと同じ名前のファイル) を使用できます。 コマンド ラインを直接使用する場合に、シグネチャ ファイルをコンパイル コマンド ラインに追加することもできます。 コード ファイルとシグネチャ ファイルを区別するために、コード ファイルは " *実装ファイル*" と呼ばれることもあります。 プロジェクトでは、シグネチャ ファイルが、関連するコード ファイルよりも優先されます。

シグネチャ ファイルは、対応する実装ファイル内の名前空間、モジュール、型、およびメンバーについて説明します。 シグネチャ ファイルの情報を使用して、対応する実装ファイルのどのコードの部分に、実装ファイルの外部コードからアクセスできるのか、また、どの部分が実装ファイルの内部用なのかを指定します。 シグネチャ ファイルに含まれる名前空間、モジュール、型は、実装ファイルに含まれている名前空間、モジュール、型のサブセットである必要があります。 このトピックの後半で例外をいくつか挙げますが、シグネチャ ファイルにリストされていない言語要素は、実装ファイルのプライベートな要素と見なされます。 プロジェクトまたはコマンド ラインでシグネチャ ファイルが見つからない場合は、既定のアクセシビリティが使用されます。

既定のアクセシビリティの詳細については、「[アクセスの制御](access-control.md)」を参照してください。

シグネチャ ファイルでは、各メソッドおよび関数の型および実装の定義は繰り返しません。 代わりに、各メソッドおよび関数のシグネチャを使用します。これは、モジュールまたは名前空間のフラグメントによって実装されている機能の完全な仕様として機能します。 型シグネチャの構文は、インターフェイスと抽象クラスの抽象メソッドの宣言で使用される構文と同じです。また、正しくコンパイルされた入力を表示するとき、IntelliSense および F# インタープリター fsi.exe によっても表示されます。

型がシールされているかどうか、またはインターフェイス型であるかどうかを示す十分な情報が型シグネチャにない場合、コンパイラに型の性質を示す属性を追加する必要があります。 次の表に、この目的で使用する属性を示します。

|属性|説明|
|---------|-----------|
|`[<Sealed>]`|抽象メンバーを持たない型、または拡張する必要がない型の場合。|
|`[<Interface>]`|インターフェイスである型の場合。|

シグネチャと実装ファイルの宣言との間で属性が一致しない場合、コンパイラはエラーを生成します。

キーワード `val` を使用して、値または関数値のシグネチャを作成します。 キーワード `type` は、型シグネチャを導入します。

`--sig` コンパイラ オプション使用して、シグネチャ ファイルを生成できます。 通常、.fsi ファイルは手動で作成しません。 代わりに、コンパイラを使用して .fsi ファイルを生成し、そのファイルをプロジェクトに追加します。既にファイルが存在する場合、アクセスできるようにしたくないメソッドや関数を削除することによって編集します。

型シグネチャには、以下のようないくつかのルールがあります。

- 実装ファイルの型略称は、シグネチャ ファイルの省略しない型と一致してはなりません。

- レコードと、判別された共用体は、フィールドとコンストラクターをすべて公開するか、または一切公開しない必要があります。また、シグネチャの順序は、実装ファイルの順序と一致している必要があります。 クラスは、シグネチャのフィールドとメソッドの一部またはすべてを表示することも、あるいは一切表示しないこともできます。

- コンストラクターを持つクラスと構造体は、基底クラスの宣言 ( `inherits` の宣言) を公開する必要があります。 また、コンストラクターを持つクラスと構造体は、抽象メソッドとインターフェイス宣言すべてを公開する必要があります。

- インターフェイスの型は、すべてのメソッドとインターフェイスを表示する必要があります。

値シグネチャの規則は次のとおりです。

- アクセシビリティの修飾子 (`public`、 `internal`など) およびシグネチャにおける `inline` と `mutable` の修飾子は、実装の修飾子と一致している必要があります。

- ジェネリック型パラメーターの数 (暗黙的に推定される、または明示的に宣言される) は一致している必要があります。また、ジェネリック型パラメーターの型と型制約は一致している必要があります。

- `Literal` 属性を使用する場合、その属性はシグネチャと実装の両方に表示される必要があります。また、同じリテラル値を両方に使用する必要があります。

- シグネチャと実装のパラメーターのパターン ( *アリティ* とも呼ばれます) は、一致している必要があります。

- シグネチャ ファイル内のパラメーター名が対応する実装ファイルと異なる場合は、シグネチャ ファイル内の名前が代わりに使用されます。これにより、デバッグまたはプロファイル時に問題が発生する可能性があります。 このような不一致について通知されるようにするには、プロジェクト ファイルで、またはコンパイラを呼び出す際に警告 3218 を有効にします (「[コンパイラ オプション](compiler-options.md)」で `--warnon` を参照してください)。

次のコード例では、適切な属性と共に名前空間、モジュール、関数値、型シグネチャを持つシグネチャ ファイルの例を示します。 また、対応する実装ファイルも示します。

[!code-fsharp[Main](~/samples/snippets/fsharp/fssignatures/snippet9002.fs)]

次のコードは実装ファイルを示します。

[!code-fsharp[Main](~/samples/snippets/fsharp/fssignatures/snippet9001.fs)]

## <a name="see-also"></a>関連項目

- [F# 言語リファレンス](index.md)
- [アクセス制御](access-control.md)
- [コンパイラ オプション](compiler-options.md)
