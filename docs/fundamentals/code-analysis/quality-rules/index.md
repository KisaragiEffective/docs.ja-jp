---
title: コード品質ルールの概要
description: コード分析に使用できるすべてのコード品質規則について説明します。
ms.date: 09/01/2020
ms.topic: reference
author: mikadumont
ms.author: midumont
ms.openlocfilehash: f62d6a0e44e29375987e7c62b1868808f4bb0cc3
ms.sourcegitcommit: ddf7edb67715a5b9a45e3dd44536dabc153c1de0
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 02/06/2021
ms.locfileid: "103235223"
---
# <a name="code-quality-rules"></a>コード品質規則

.NET コード分析には、コードの品質向上を目的とした規則が用意されています。 規則は、デザイン、グローバリゼーション、パフォーマンス、セキュリティなどの区分に分類されています。 特定の規則は .NET API の使用に固有であり、他の規則は一般的なコードの品質に関するものです。

## <a name="index-of-rules"></a>規則のインデックス

次の表に、コード品質分析規則の一覧を示します。

> [!div class="mx-tdCol2BreakAll"]
> | 規則 ID と警告 | 説明 |
> | - | - |
> | [CA1000:ジェネリック型の静的メンバーを宣言しません](ca1000.md) | ジェネリック型の静的メンバーを呼び出すときには、その型の型引数も指定する必要があります。 推論をサポートしないジェネリック インスタンス メンバーを呼び出すときには、そのメンバーに型引数を指定する必要があります。 この 2 つの場合、型引数を指定するときに使用される構文は異なりますが、混同される可能性があります。 |
> | [CA1001:破棄可能なフィールドを所有する型は、破棄可能でなければなりません](ca1001.md) | クラスが System.IDisposable 型であるインスタンス フィールドを宣言および実装していますが、IDisposable を実装していません。 IDisposable フィールドを宣言するクラスは間接的にアンマネージ リソースを所有しているため、IDisposable インターフェイスを実装する必要があります。 |
> | [CA1002:ジェネリック リストを公開しません](ca1002.md) | System.Collections.Generic.List<(Of \<(T>)>) は継承ではなくパフォーマンスを目的としたジェネリック コレクションです。 このため、List には仮想メンバーは含まれません。 代わりに、継承を目的としたジェネリック コレクションを公開する必要があります。 |
> | [CA1003:汎用イベント ハンドラーのインスタンスを使用します](ca1003.md) |型に void を返すデリゲートが含まれており、デリゲートのシグネチャに 2 つのパラメーター (1 つはオブジェクト、もう 1 つは EventArgs に割り当て可能な型) が含まれ、包含アセンブリの対象が Microsoft .NET Framework 2.0. です。 |
> | [CA1005:ジェネリック型でパラメーターを使用しすぎないでください](ca1005.md) | ジェネリック型に含まれる型パラメーターが増えれば増えるほど、それぞれの型パラメーターが表す意味を調べることや覚えることが難しくなります。 通常、List\<T> のように型パラメーターが 1 つの場合や、Dictionary\<TKey, TValue> のように型パラメーターが 2 つの場合、意味は明確です。 しかし、型パラメーターが 3 つ以上になると、ほとんどのユーザーには意味を把握することが困難になります。 |
> | [CA1008:Enums は 0 値を含んでいなければなりません](ca1008.md) | 初期化されていない列挙型の既定値は、他の値型と同様に、ゼロです。 フラグではない属性が付いた列挙型では、ゼロの値を使用してメンバーを定義する必要があります。これは、既定値を有効な列挙値にするためです。 FlagsAttribute 属性を適用した列挙型でゼロ値のメンバーを定義する場合、名前を "None" にして、列挙型に設定済みの値がないことを示します。 |
> | [CA1010:コレクションは、ジェネリック インターフェイスを実装しなければなりません](ca1010.md) | コレクションの操作性を拡充するために、ジェネリック コレクション インターフェイスの 1 つを実装します。 これにより、コレクションを使用してジェネリック コレクション型を設定できます。 |
> | [CA1012:抽象型にはコンストラクターを含めません](ca1012.md) | 抽象型上のコンストラクターは、派生型からのみ呼び出すことができます。 パブリック コンストラクターで型のインスタンスが作成され、抽象型のインスタンスは自分で作成できないため、パブリック コンストラクターが含まれる抽象型のデザインは不適切になります。 |
> | [CA1014:アセンブリに CLSCompliantAttribute を設定します](ca1014.md) | 共通言語仕様 (CLS) には、名前付けの制約、データ型、および規則が定義されています。アセンブリを複数のプログラミング言語で使用する場合、この仕様に準拠する必要があります。 すべてのアセンブリに <xref:System.CLSCompliantAttribute> を使用して、CLS への準拠を明示することをお勧めします。 この属性が使用されていないアセンブリは、CLS に準拠しません。 |
> | [CA1016:アセンブリに AssemblyVersionAttribute を設定します](ca1016.md) | .NET では、バージョン番号を使用してアセンブリを一意に識別し、厳密な名前を持つアセンブリの型にバインドします。 バージョン番号は、バージョンと発行者のポリシーと共に使用されます。 既定で、アプリケーションは、ビルドされたアセンブリのバージョンでのみ実行されます。 |
> | [CA1017:アセンブリに ComVisibleAttribute を設定します](ca1017.md) |ComVisibleAttribute 属性によって、COM クライアントからマネージド コードにアクセスする方法が決まります。 アセンブリで COM の参照範囲を明示することをお勧めします。 COM の参照範囲は、アセンブリ全体に設定し、個々の型と型のメンバー用にオーバーライドできます。 この属性がない場合、アセンブリのコンテンツは COM クライアントから参照できます。 |
> | [CA1018:属性を AttributeUsageAttribute に設定します](ca1018.md) | カスタム属性を定義する場合、AttributeUsageAttribute を使用してマークし、カスタム属性を適用できるソース コードの位置を示します。 属性の意味と用途によって、コード内の有効な位置が決まります。 |
> | [CA1019:属性引数にアクセサーを定義します](ca1019.md) | 属性では、対象に適用するときに必ず指定する必須の引数を定義できます。 この引数は、コンストラクターに位置指定パラメーターで属性を指定できるようになるため、位置指定引数とも呼ばれます。 必須のすべての引数について、対応する読み取り専用のプロパティも属性で規定する必要があります。これは、引数値を実行時に取得できるようにするためです。 また、属性ではオプションの引数も定義できます。これは名前付き引数とも呼ばれます。 この引数は、名前でコンストラクターに属性を指定するときに使用されます。また、対応する読み取り/書き込みプロパティが必要です。 |
> | [CA1021:out パラメーターを使用しません](ca1021.md) | (out または ref を使用した) 型の参照渡しには、ポインターの使用経験、値型と参照型の違いの理解、および複数の戻り値を持つメソッドの処理が必要です。 また、out パラメーターと ref パラメーターの違いはあまり理解されていません。 |
> | [CA1024:適切な場所にプロパティを使用します](ca1024.md) | パブリック メソッドまたはプロテクト メソッドに、"Get" で始まる名前が付けられ、パラメーターは使用されていません。また、配列ではない値を返します。 このメソッドは、プロパティに変更できる可能性があります。 |
> |[CA1027:列挙型を FlagsAttribute に設定します](ca1027.md) | 列挙型は、関連する名前付き定数が複数定義された値型です。 名前付き定数を有意に結合できる場合、列挙型に FlagsAttribute を適用します。 |
> | [CA1028:列挙ストレージは Int32 でなければなりません](ca1028.md) | 列挙型は、関連する名前付き定数が複数定義された値型です。 既定で、System.Int32 データ型は、定数値を格納するために使用されます。 この基になる型を変更できる場合でも、ほとんどの場合、変更する必要はなく、推奨もされません。 |
> | [CA1030:適切な場所にイベントを使用します](ca1030.md) |この規則では、通常はイベントに使用される名前を持つメソッドを検出します。 明示的に定義された状態変化に応答してメソッドが呼び出される場合、メソッドはイベント ハンドラーから呼び出す必要があります。 メソッドを呼び出すオブジェクトは、メソッドを直接呼び出すのではなく、イベントを発生させる必要があります。 |
> | [CA1031:一般的な例外の種類はキャッチしません](ca1031.md) | 汎用的な例外はキャッチしないでください。 より具体的な例外をキャッチするか、汎用的な例外を catch ブロックの最後のステートメントでスローし直します。 |
> |[CA1032:標準例外コンストラクターを実装します](ca1032.md) | コンストラクターを完全に宣言していないと、例外を正しく処理するのが困難になります。 |
> | [CA1033:インターフェイス メソッドは、子型によって呼び出し可能でなければなりません](ca1033.md) | シールされていない外部から参照できる型によって、パブリック インターフェイスを持つメソッドを明示的に実装しています。また、同じ名前を持つ外部から参照できる代替のメソッドがありません。 |
> | [CA1034:入れ子にされた型を参照可能にすることはできません](ca1034.md) | 入れ子にされた型とは、別の型のスコープ内で宣言された型のことです。 入れ子にされた型は、包含型のプライベート実装の詳細をカプセル化するときに便利です。 このような用途なので、入れ子にされた型は外部から参照できないようにします。 |
> | [CA1036:比較可能な型でメソッドをオーバーライドします](ca1036.md) |パブリック型またはプロテクト型で System.IComparable インターフェイスを実装しています。 これによって、Object.Equals はオーバーライドされません。また、"等しい"、"等しくない"、"未満"、"より大きい" を示す言語固有の演算子はオーバーロードされません。 |
> |[CA1040:空のインターフェイスは使用しません](ca1040.md) | インターフェイスには、動作や使用のコントラクトを実現するメンバーが定義されます。 インターフェイスで示される機能は、継承の階層構造内に型が存在するかどうかにかかわらず、どの型からも適用できます。 型ではインターフェイスのメンバーに実装することで、インターフェイスが実装されます。 空のインターフェイスではメンバーが定義されません。そのため、実装できるコントラクトも定義されません。 |
> | [CA1041:ObsoleteAttribute メッセージを指定します](ca1041.md) | 型またはメンバーが System.ObsoleteAttribute 属性を使用してマークされていますが、この属性で ObsoleteAttribute.Message プロパティが指定されていません。 ObsoleteAttribute でマークされている型またはメンバーをコンパイルすると、属性の Message プロパティが表示されます。 これによって、ユーザーは旧式の型またはメンバーに関する情報を知ることができます。 |
> | [CA1043:インデクサーには整数または文字列引数を使用します](ca1043.md) | インデクサー (つまり、インデックスされたプロパティ) では、インデックスに整数型または文字列型を使用します。 一般に、このような型はデータ構造のインデックス作成に使用され、ライブラリの操作性も改善されます。 Object 型の使用は、デザイン時に特定の整数型または文字列型を指定できない場合に限定してください。 |
> | [CA1044:プロパティを書き込み専用にすることはできません](ca1044.md) | 読み取り専用のプロパティは許容され、必要な場合もよくありますが、書き込み専用のプロパティを使用することはデザインのガイドラインで禁止されています。 これは、値を設定できてもその値を参照できず、セキュリティが確保されないためです。 また、読み取りアクセスがないと、共有オブジェクトのステータスを参照できないため、実用性が制限されます。 |
> |[CA1045:型を参照によって渡しません](ca1045.md) | (out または ref を使用した) 型の参照渡しには、ポインターの使用経験、値の型と参照型の違いの理解、および複数の戻り値を持つメソッドの処理が必要です。 開発者全般に向けてライブラリをデザインする場合、ユーザーが `out` パラメーターまたは `ref` パラメーターの扱い方を習得することは期待しないでください。 |
> | [CA1046:参照型で、演算子 equals をオーバーロードしないでください](ca1046.md) | 参照型の場合、等値演算子は既定の実装でほぼ問題がありません。 既定で、2 つの参照が等値と見なされるのは、同じオブジェクトを参照する場合のみです。 |
> |[CA1047:シールド型の保護されたメンバーを宣言しません](ca1047.md) | 型でプロテクト メンバーを宣言するのは、継承する型からメンバーにアクセスまたはオーバーライドできるようにするためです。 定義により、シールされた型から継承することはできません。これは、シールされた型のプロテクト メソッドを呼び出すことができないということを意味します。 |
> | [CA1050:名前空間で型を宣言します](ca1050.md) | 型を名前空間内で宣言するのは、名前が衝突しないようにするためと、関連する型をオブジェクト階層形式で編成するためです。 |
> | [CA1051:参照可能なインスタンス フィールドを宣言しません](ca1051.md) | フィールドの主な用途は、実装の詳細にする必要があります。 フィールドは private または internal にし、プロパティによって公開するようにします。 |
> | [CA1052:スタティック ホルダー型はシールドされていなければなりません](ca1052.md) | パブリック型またはプロテクト型に静的メンバーしかなく、sealed (C# リファレンス) (NotInheritable) 修飾子を使用して宣言されていません。 継承を意図していない型は、sealed 修飾子を使用してマークし、基本型として使用できないようにします。 |
> |[CA1053:スタティック ホルダー型はコンストラクターを含むことはできません](ca1053.md) | パブリック型または入れ子になったパブリック型で、静的なメンバーのみが宣言されています。また、パブリックまたはプロテクトの既定のコンストラクターが含まれます。 静的メンバーの呼び出しに型のインスタンスは必要ないため、コンストラクターは不要です。 安全性とセキュリティを確保するために、文字列引数を使用して文字列オーバーロードで URI (Uniform Resource Identifier) オーバーロードを呼び出してください。 |
> | [CA1054:URI パラメーターを文字列にすることはできません](ca1054.md) | メソッドで URI の文字列形式を使用する場合、対応するオーバーロードを宣言し、URI クラスのインスタンスを使用します。こうすることで、安全な方法でこのサービスを実現できます。 |
> | [CA1055:URI 戻り値を文字列にすることはできません](ca1055.md) | この規則では、メソッドは URI を返すと想定されます。 URI の文字列表現は解析エラーやエンコーディング エラーが発生しやすく、セキュリティ上の脆弱性の原因となる場合があります。 System.Uri クラスを使用すると、安全な方法でこのサービスを実現できます。 |
> | [CA1056:URI プロパティを文字列にすることはできません](ca1056.md) | この規則では、プロパティは URI (Uniform Resource Identifier) を表すと想定されます。 URI の文字列表現は解析エラーやエンコーディング エラーが発生しやすく、セキュリティ上の脆弱性の原因となる場合があります。 System.Uri クラスを使用すると、安全な方法でこのサービスを実現できます。 |
> | [CA1058:型は、一定の基本型を拡張することはできません](ca1058.md) | 外部から参照可能な型では、特定の基本型が拡張されます。 別の型を使用してください。 |
> | [CA1060: P/Invoke を NativeMethods クラスに移動します](ca1060.md) | System.Runtime.InteropServices.DllImportAttribute 属性でマークされているメソッドなどのプラットフォーム呼び出しメソッド、または Visual Basic で `Declare` キーワードを使用して定義されたメソッドから、アンマネージド コードにアクセスしています。 これらのメソッドは、NativeMethods、SafeNativeMethods、UnsafeNativeMethods の各クラスのいずれかに含まれる必要があります。 |
> |[CA1061:基底クラス メソッドを非表示にしません](ca1061.md) | 派生メソッドのパラメーター シグネチャ内のある型が、基本メソッドのパラメーター シグネチャ内のそれに対応する型より弱く型指定されていることが、両者の唯一の相違点である場合、基本型内のメソッドが派生型内の同じ名前のメソッドによって隠ぺいされます。 |
> | [CA1062:パブリック メソッドの引数の検証](ca1062.md) | 外部から参照可能なメソッドに渡されるすべての参照引数について、null かどうかをチェックする必要があります。 |
> | [CA1063:IDisposable を正しく実装します](ca1063.md) | すべての IDisposable 型は、Dispose パターンを適切に実装する必要があります。 |
> | [CA1064:例外は public として設定する必要があります](ca1064.md) | 内部例外は、その内部スコープ内でのみ認識されます。 内部スコープの外側にある例外は、基本例外を使用しなければキャッチできません。 内部例外が <xref:System.Exception>、<xref:System.SystemException>、または <xref:System.ApplicationException> を継承している場合、外部コードはその例外の処理に関する十分な情報を取得できません。 |
> | [CA1065:予期しない場所に例外を発生させません](ca1065.md) | 例外をスローしないはずのメソッドが例外をスローします。 |
> | [CA1066: Equals をオーバーライドする際に IEquatable を実装します](ca1066.md) | 値の型では、<xref:System.Object.Equals%2A> をオーバーライドしていますが、<xref:System.IEquatable%601>を実装していません。 |
> | [CA1067: IEquatable を実装するときに Equals をオーバーライドします](ca1067.md) | 型では <xref:System.IEquatable%601> を実装していますが、<xref:System.Object.Equals%2A> メソッドをオーバーライドしていません。 |
> | [CA1068:CancellationToken パラメーターは最後に指定する必要があります](ca1068.md) | メソッドに、最後のパラメーターではない CancellationToken パラメーターが指定されています。 |
> | [CA1069: 列挙型には重複する値を指定できません](ca1069.md) | 列挙型に、同じ定数値が明示的に割り当てられている複数のメンバーがあります。 |
> | [CA1070: イベント フィールドを virtual として宣言しません](ca1070.md) | [フィールドのように使用するイベント](../../../csharp/event-pattern.md#defining-and-raising-field-like-events)が virtual として宣言されました。 |
> | [CA1200:プレフィックスで cref タグを使用しません](ca1200.md) | XML ドキュメント タグの [cref](../../../csharp/programming-guide/xmldoc/cref-attribute.md) 属性は "コード参照" を意味します。 タグの内部テキストが、型、メソッド、プロパティなど、コード要素であることを指定します。 `cref` タグとプレフィックスを一緒に使用すると、コンパイラで参照を検証できなくなるため、一緒に使用しないでください。 また、Visual Studio 統合開発環境 (IDE) でリファクタリング中にこれらのシンボル参照を見つけたり、更新したりすることもできなくなります。 |
> | [CA1303:ローカライズされるパラメーターとしてリテラルを渡さない](ca1303.md) | 外部から参照できるメソッドで、.NET コンストラクターまたはメソッドへのパラメーターとして、リテラル文字列を渡しています。その文字列はローカライズ可能です。 |
> | [CA1304:CultureInfo を指定します](ca1304.md) | System.Globalization.CultureInfo パラメーターを受け入れるオーバーロードを持つメンバーを呼び出しているメソッドまたはコンストラクターが、CultureInfo パラメーターを使用するオーバーロードを呼び出していません。 CultureInfo オブジェクトまたは System.IFormatProvider オブジェクトが指定されない場合、オーバーロードされたメンバーから提示された既定値は、すべてのロケールに効果が及ばない可能性があります。 |
> | [CA1305:IFormatProvider を指定します](ca1305.md) | System.IFormatProvider パラメーターを受け入れるオーバーロードを持つメンバーを 1 つ以上呼び出しているメソッドまたはコンストラクターが、IFormatProvider パラメーターを使用するオーバーロードを呼び出していません。 System.Globalization.CultureInfo オブジェクトまたは IFormatProvider オブジェクトが指定されない場合、オーバーロードされたメンバーから提示された既定値は、すべてのロケールに効果が及ばない可能性があります。 |
> | [CA1307:意味を明確にするための StringComparison の指定](ca1307.md) | 文字列比較演算で、StringComparison パラメーターを設定しないメソッド オーバーロードが使用されています。 |
> |[CA1308:文字列を大文字に標準化します](ca1308.md) | 文字列は大文字に正規化する必要があります。 小文字への変換時に 1 つの小さい文字グループをラウンド トリップさせることができません。 |
> | [CA1309:順序を示す StringComparison を使用します](ca1309.md) | 非言語的な文字列比較演算で、StringComparison パラメーターが Ordinal または OrdinalIgnoreCase に設定されていません。 パラメーターを StringComparison.Ordinal または StringComparison.OrdinalIgnoreCase に明示的に設定することによって、多くの場合、コードの速度、正確さ、および信頼性が向上します。 |
> | [CA1310:正確な StringComparison の指定](ca1310.md) | 文字列比較演算で、StringComparison パラメーターが設定されておらず、カルチャ固有の文字列比較が既定で使用されるメソッド オーバーロードを使用しています。 |
> | [CA1401: P/Invoke は参照可能になりません](ca1401.md) | パブリック型のパブリック メソッドまたはプロテクト メソッドに、System.Runtime.InteropServices.DllImportAttribute 属性があります (Visual Basic では Declare キーワードでも実装されます)。 このようなメソッドは公開しないでください。 |
> | [CA1416:プラットフォームの互換性を検証する](ca1416.md) | プラットフォーム依存 API をコンポーネント上で使用すると、一部のプラットフォームでコードが動作しなくなります。 |
> | [CA1417: P/Invokes の文字列パラメーターに `OutAttribute` を使用しません](ca1417.md) | 文字列がインターン処理された文字列で、文字列パラメーターが `OutAttribute` の値で渡された場合、ランタイムが不安定になる可能性があります。 |
> | [CA1501:継承を使用しすぎないでください](ca1501.md) | 型が、その継承階層内の 5 つ以上深いレベルにあります。 深いレベルで入れ子にされた型の確認、理解、および保守は困難です。 |
> | [CA1502:メソッドの実装を複雑にしすぎないでください](ca1502.md) | この規則は、線形独立のメソッド経路数を示す尺度で、条件分岐の数と複雑さによって決まります。 |
> | [CA1505:メンテナンスできないコードを使用しないでください](ca1505.md) | 型またはメソッドの保守容易性指数が低い値です。 保守容易性指数の低い型またはメソッドは、保守が困難な可能性があるため、デザインの変更を検討することをお勧めします。 |
> | [CA1506:クラス結合度を大きくしすぎないでください](ca1506.md) | この規則は、型またはメソッドに含まれる一意の型参照の数をカウントすることによって、クラス結合度を計測します。 |
> | [CA1507:文字列の代わりに nameof を使用します](ca1507.md) | `nameof` 式を使用できる場合に、文字列リテラルが引数として使用されています。 |
> | [CA1508:使用されない条件付きコードを回避する](ca1508.md) | 実行時に常に `true` または `false` と評価される条件付きコードがメソッドにあります。 このため、条件の `false` 分岐で実行されないコードになります。 |
> | [CA1509: コード メトリック構成ファイルのエントリが無効です](ca1509.md) | [CA1501](ca1501.md)、[CA1502](ca1502.md)、[CA1505](ca1505.md)、[CA1506](ca1506.md) などのコード メトリック規則で、無効なエントリを含んだ `CodeMetricsConfig.txt` という名前の構成ファイルが指定されました。 |
> | [CA1700:列挙型値に 'Reserved' という名前を指定しません](ca1700.md) | この規則では、"reserved" を含む名前の列挙体のメンバーは、現在使用されていなくても、将来的なバージョンでは名前を変更するか削除されるプレースホルダーと想定しています。 メンバーの名前変更や削除は、互換性に影響する変更点です。 |
> | [CA1707:識別子はアンダースコアを含むことはできません](ca1707.md) | 名前付け規則では、識別子名にアンダースコア (_) 文字を含めることができません。 この規則により、名前空間、型、メンバー、およびパラメーターがチェックされます。 |
> | [CA1708:識別子は、大文字と小文字の区別以外にも相違していなければなりません](ca1708.md) | 名前空間、型、メンバー、およびパラメーターの各識別子は、大文字/小文字以外のみでは区別できません。共通言語ランタイムを対象とする言語は、大文字と小文字を区別する必要はないためです。 |
> | [CA1710:識別子は、正しいサフィックスを含んでいなければなりません](ca1710.md) |名前付け規則によると、特定の基本型を拡張した型、特定のインターフェイスを実装する型、またはそのような型の派生型は、基本型やインターフェイスに関連するサフィックスを名前に付けます。 |
> | [CA1711:識別子は、不適切なサフィックスを含むことはできません](ca1711.md) | 規則では、特定の基本型を拡張する型、特定のインターフェイスを実装する型、またはそのような型から派生した型の名前にのみ、固有の予約済みサフィックスを末尾に付けます。 その他の型名では、予約済みのサフィックスを使用しないでください。 |
> | [CA1712:列挙型値を型名のプレフィックスにしません](ca1712.md) | 型情報は開発ツールで表示されるため、列挙型のメンバー名には、型名のプレフィックスを付けません。 |
> | [CA1713:イベントは、before または after プレフィックスを含むことはできません](ca1713.md) | イベント名が "Before" または "After" で始まっています。 特定のシーケンスで発生する関連イベントに名前を付ける場合、現在時制または過去時制を使用して、アクション シーケンスの相対的な位置を示します。 |
> | [CA1714:フラグ列挙型は、複数形の名前を含んでいなければなりません](ca1714.md) | パブリック列挙体に System.FlagsAttribute 属性があり、その名前の末尾に "s" がありません。 FlagsAttribute でマークされた型は複数形の名前を持ちます。これは、この属性が複数の値を指定できることを示すからです。 |
> | [CA1715:識別子は正しいプレフィックスを含んでいなければなりません](ca1715.md) | 外部から参照できるインターフェイスの名前が大文字の "I" から始まっていません。 外部から参照できる型またはメソッドのジェネリック型パラメーターの名前が、大文字の "T" から始まっていません。 |
> | [CA1716:識別子はキーワードと同一にすることはできません](ca1716.md) | 名前空間の名前または型の名前が、プログラミング言語で、予約済みのキーワードと一致します。 名前空間と型の識別子は、共通言語ランタイムを対象にする言語で定義されているキーワードと一致しないようにします。 |
> | [CA1717:FlagsAttribute 列挙型のみが複数形の名前を含んでいなければなりません](ca1717.md) | 名前付け規則では、列挙体の複数形の名前は同時に複数の列挙値を指定できることを意味します。 |
> |[CA1720:識別子には型名を含めないでください](ca1720.md) | 外部から参照できるメンバーのパラメーター名にデータ型の名前が含まれているか、外部から参照できるメンバーの名前に言語固有のデータ型の名前が含まれています。 |
> | [CA1721:プロパティ名は get メソッドと同一にすることはできません](ca1721.md) |パブリック メンバーまたはプロテクト メンバーの名前が、"Get" から始まっているか、パブリック プロパティまたはプロテクト プロパティの名前と一致します。 "Get" メソッドとプロパティには、それぞれの機能を明確に区別する名前を指定しなければなりません。 |
> | [CA1724:型名は名前空間と同一にすることはできません](ca1724.md) | 型名は .NET 名前空間と同一にすることはできません。 この規則に違反すると、ライブラリが使いづらくなります。 |
> | [CA1725:パラメーター名は基本宣言と同一でなければなりません](ca1725.md) | オーバーライド階層のパラメーターに対する一貫性のある名前付けによって、メソッド オーバーライドの有用性が高まります。 派生メソッドのパラメーター名が基本宣言のパラメーター名と異なる場合、メソッドが基本メソッドのオーバーライドであるか、またはメソッドの新しいオーバーライドであるかについて混乱が生じる可能性があります。 |
> | [CA1801:使用されていないパラメーターの確認](ca1801.md) | メソッドのシグネチャに、メソッドの本体で使用されていないパラメーターがあります。 |
> |[CA1802:適切な場所にリテラルを使用します](ca1802.md) |フィールドが static および read-only (Visual Basic では Shared および ReadOnly) として宣言され、コンパイル時に計算できる値によって初期化されています。 対象フィールドに代入された値はコンパイル時に計算できるので、宣言を const (Visual Basic では Const) フィールドに変更して、値が実行時ではなくコンパイル時に計算されるようにします。 |
> | [CA1805: 不必要に初期化しない](ca1805.md) | .NET ランタイムでは、コンストラクターを実行する前に参照型のすべてのフィールドを既定値に初期化します。 ほとんどの場合、フィールドを明示的に既定値に初期化することは冗長であり、メンテナンス コストが増加し、パフォーマンスが低下 (アセンブリのサイズの増加など) する可能性があります。 |
> | [CA1806:メソッドの結果を無視しない](ca1806.md) | 新しく作成されたオブジェクトが現在まで使用されていないか、新しい文字列を作成して返すメソッドが呼び出されて作成された新しい文字列が現在まで使用されていません。あるいは、COM または P/Invoke メソッドから返された HRESULT またはエラー コードが現在まで使用されていません。 |
> | [CA1810:参照型の静的フィールドをインラインで初期化します](ca1810.md) | 型で明示的な静的コンストラクターを宣言すると、Just-In-Time (JIT) コンパイラが、静的コンストラクターが呼び出されたことを確認するために、型の静的メソッドと静的インスタンス コンストラクターに個別にチェックを追加します。 静的コンストラクターのチェックによってパフォーマンスが低下することがあります。 |
> | [CA1812:インスタンス化されていない内部クラスを使用しません](ca1812.md) | アセンブリ レベルの型のインスタンスが、アセンブリ内のコードから作成されません。 |
> | [CA1813:アンシールド属性を使用しません](ca1813.md) | .NET には、カスタム属性を取得するメソッドが用意されています。 既定では、これらのメソッドで属性の継承階層が検索されます。 属性をシールすると、継承階層の全体が検索されなくなるため、パフォーマンスが向上します。 |
> | [CA1814:複数次元の配列ではなくジャグ配列を使用します](ca1814.md) | ジャグ配列とは、その要素も配列である配列です。 要素を構成する配列のサイズは異なってもよいため、データ セットによっては無駄な空間が少なくなります。 |
> | [CA1815:equals および operator equals を値型でオーバーライドします](ca1815.md) | 値型の場合、Equals を継承した実装が Reflection ライブラリを使用して、すべてのフィールドの内容を比較します。 Reflection は計算コストが高いため、場合によってはすべてのフィールドで等値性を比較する必要はありません。 ユーザーがインスタンスの比較または並べ替えを行うことや、ハッシュ テーブル キーとしてインスタンスを使用することが予想される場合には、値型に Equals を実装する必要があります。 |
> | [CA1816:GC.SuppressFinalize を正しく呼び出します](ca1816.md) | Dispose を実装するメソッドが GC.SuppressFinalize を呼び出していないか、Dispose を実装しないメソッドが GC.SuppressFinalize を呼び出しています。または、あるメソッドが GC.SuppressFinalize を呼び出し、this (Visual Basic では Me) 以外のオブジェクトを渡しています。 |
> | [CA1819:プロパティは、配列を返すことはできません](ca1819.md) | プロパティが読み取り専用であっても、プロパティで返される配列は書き込みから保護されません。 配列の改ざんを防ぐには、プロパティで配列のコピーを返す必要があります。 一般に、このようなプロパティを呼び出すときのパフォーマンス低下は理解されません。 |
> | [CA1820:文字列の長さを使用して空の文字列をテストします](ca1820.md) | String.Length プロパティまたは String.IsNullOrEmpty メソッドを使用して文字列を比較する方法は、Equals を使用する場合よりもはるかに高速です。 |
> | [CA1821:空のファイナライザーを削除します](ca1821.md) | オブジェクトの有効期間の追跡に関連するパフォーマンス オーバーヘッドが増大するため、ファイナライザーは可能な限り使用しないでください。 空のファイナライザーを使用すると、オーバーヘッドが増大するだけで何の利点もありません。 |
> |[CA1822:メンバーを static に設定します](ca1822.md) | インスタンス データにアクセスしない、またはインスタンス メソッドを呼び出さないメンバーは、静的 (Visual Basic では Shared) としてマークできます。 メソッドを静的としてマークすると、コンパイラはこれらのメンバーに対する非仮想呼び出しサイトを出力します。 パフォーマンス重視のコードでは、これにより大きくパフォーマンスを向上できます。 |
> | [CA1823:使用されていないプライベート フィールドを使用しません](ca1823.md) | アセンブリ内でアクセスされていないと思われるプライベート フィールドが検出されました。 |
> |[CA1824:アセンブリを NeutralResourcesLanguageAttribute に設定します](ca1824.md) | NeutralResourcesLanguage 属性は、リソース マネージャーに対し、アセンブリのニュートラル カルチャのリソースを表示するために使用した言語を通知します。 これにより、読み込んだ最初のリソースに対する検索のパフォーマンスが向上し、ワーキング セットを縮小できます。 |
> |[CA1825:長さ 0 の配列割り当てを回避します](ca1825.md) | 長さ 0 の配列を初期化すると、不要なメモリ割り当てが発生します。 代わりに、<xref:System.Array.Empty%2A?displayProperty=nameWithType> を呼び出して、静的に割り当てられた空の配列インスタンスを使用してください。 メモリ割り当ては、このメソッドのすべての呼び出しで共有されます。 |
> |[CA1826:Linq の列挙可能なメソッドの代わりにプロパティを使用します](ca1826.md) | <xref:System.Linq.Enumerable> LINQ メソッドが同等のより効率的なプロパティをサポートする型で使用されました。 |
> |[CA1827:Any が使用できる場合は Count/LongCount を使用しません](ca1827.md) | <xref:System.Linq.Enumerable.Any%2A> メソッドの方が効率的な状況で、<xref:System.Linq.Enumerable.Count%2A> または <xref:System.Linq.Enumerable.LongCount%2A> メソッドが使用されました。 |
> |[CA1828:AnyAsync が使用できる場合は CountAsync/LongCountAsync を使用しません](ca1828.md) | <xref:Microsoft.EntityFrameworkCore.EntityFrameworkQueryableExtensions.AnyAsync%2A> メソッドの方が効率的な状況で、<xref:Microsoft.EntityFrameworkCore.EntityFrameworkQueryableExtensions.CountAsync%2A> または <xref:Microsoft.EntityFrameworkCore.EntityFrameworkQueryableExtensions.LongCountAsync%2A> メソッドが使用されました。 |
> |[CA1829:Enumerable. Count メソッドではなく Length/Count プロパティを使用します](ca1829.md) | <xref:System.Linq.Enumerable.Count%2A> LINQ メソッドが同等のより効率的な `Length` または `Count` プロパティをサポートする型で使用されました。 |
> |[CA1830:StringBuilder の厳密に型指定された Append および Insert メソッドのオーバーロードをお勧めします](ca1830.md) | <xref:System.Text.StringBuilder.Append%2A> と <xref:System.Text.StringBuilder.Insert%2A> では、<xref:System.String> 以外の複数の型に対してオーバーロードを提供します。  可能であれば、ToString() と文字列ベースのオーバーロードを使用するよりも、厳密に型指定されたオーバーロードを優先して使用することをお勧めします。 |
> |[CA1831: 該当する場合、文字列に範囲ベースのインデクサーの代わりに AsSpan を使用します](ca1831.md) | 文字列に対して範囲インデクサーを使用し、その値を ReadOnlySpan&lt;char&gt; 型に暗黙的に割り当てると、<xref:System.Span%601.Slice%2A?#System_Span_1_Slice_System_Int32_System_Int32_> の代わりにメソッド <xref:System.String.Substring%2A?#System_String_Substring_System_Int32_System_Int32_> が使用されます。これにより、文字列の要求された部分のコピーが生成されます。 |
> |[CA1832: 配列の ReadOnlySpan または ReadOnlyMemory 部分を取得するために、範囲ベースのインデクサーの代わりに AsSpan または AsMemory を使用します](ca1832.md) | 配列に対して範囲インデクサーを使用し、その値を <xref:System.ReadOnlySpan%601> または <xref:System.ReadOnlyMemory%601> 型に暗黙的に割り当てると、<xref:System.Span%601.Slice%2A?#System_Span_1_Slice_System_Int32_System_Int32_> の代わりにメソッド <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetSubArray%2A> が使用されます。これにより、配列の要求された部分のコピーが生成されます。 |
> |[CA1833: 配列の Span または Memory 部分を取得するために、範囲ベースのインデクサーの代わりに AsSpan または AsMemory を使用します](ca1833.md) | 配列に対して範囲インデクサーを使用し、その値を <xref:System.Span%601> または <xref:System.Memory%601> 型に暗黙的に割り当てると、<xref:System.Span%601.Slice%2A?#System_Span_1_Slice_System_Int32_System_Int32_> の代わりにメソッド <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetSubArray%2A> が使用されます。これにより、配列の要求された部分のコピーが生成されます。 |
> |[CA1834:1 文字の文字列に対して StringBuilder.Append(char) を使用する](ca1834.md) | <xref:System.Text.StringBuilder> には、引数として `char` を取る `Append` オーバーロードがあります。 パフォーマンス上の理由から、`char` オーバーロードを呼び出すことをお勧めします。 |
> |[CA1835: 'ReadAsync' および 'WriteAsync' で 'Memory' ベースのオーバーロードを優先的に使用します](ca1835.md) | 'Stream' には、最初の引数として 'Memory&lt;Byte&gt;' を取る 'ReadAsync' オーバーロードと、最初の引数として 'ReadOnlyMemory&lt;Byte&gt;' を取る 'WriteAsync' オーバーロードがあります。 より効率的なメモリ ベースのオーバーロードを呼び出すことをお勧めします。 |
> |[CA1836: 使用可能な場合は、`Count` よりも `IsEmpty` を優先します](ca1836.md) | オブジェクトに項目が含まれているかどうかを確認するときは、`Count`、`Length`、<xref:System.Linq.Enumerable.Count%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29>、<xref:System.Linq.Enumerable.LongCount%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> よりも効率的な `IsEmpty` プロパティを使用することをお勧めします。 |
> | [CA1837: `Process.GetCurrentProcess().Id` ではなく `Environment.ProcessId` を使用します](ca1837.md) | `Environment.ProcessId` は `Process.GetCurrentProcess().Id` よりも簡単かつ高速です。 |
> | [CA1838: P/Invokes に `StringBuilder` パラメーターを使用しません](ca1838.md) | 'StringBuilder' をマーシャリングすると、ネイティブ バッファーのコピーが常に作成され、1 回のマーシャリング操作に対して複数の割り当てが発生します。 |
> | [CA2000:スコープを失う前にオブジェクトを破棄](ca2000.md) | 例外的なイベントが発生するとオブジェクトのファイナライザーを実行できないため、オブジェクトに対するすべての参照がスコープ外になる前に、オブジェクトを明示的に破棄する必要があります。 |
> |[CA2002:弱い ID を伴うオブジェクト上でロックしません](ca2002.md) |アプリケーション ドメインの境界を越えてオブジェクトに直接アクセスできる場合、そのオブジェクトの ID は不十分と表現されます。 スレッドで ID が不十分なオブジェクトをロックしようとすると、ブロックされることがあります。たとえば、異なるアプリケーション ドメインの別スレッドで、既に同じオブジェクトがロックされている場合です。 |
> | [CA2007:タスクを直接待機しないでください](ca2007.md) | 非同期メソッドでは <xref:System.Threading.Tasks.Task> を直接[待機](../../../csharp/language-reference/operators/await.md)します。 非同期メソッドで <xref:System.Threading.Tasks.Task> を直接待機すると、タスクを作成したのと同じスレッドで継続が発生します。 この動作はパフォーマンスの面で大きな負担が生じ、その結果 UI スレッドでデッドロックが発生する可能性があります。 <xref:System.Threading.Tasks.Task.ConfigureAwait(System.Boolean)?displayProperty=nameWithType> を呼び出して継続の意図を示すことを検討してください。 |
> | [CA2008:TaskScheduler を渡さずにタスクを作成しない](ca2008.md) | タスクの作成または継続の操作で、<xref:System.Threading.Tasks.TaskScheduler> パラメーターを指定しないメソッド オーバーロードを使用しています。 |
> | [CA2009: ImmutableCollection 値で ToImmutableCollection を呼び出さないでください](ca2009.md) | `ToImmutable` メソッドが <xref:System.Collections.Immutable> 名前空間から変更できないコレクションで不必要に呼び出されました。 |
> | [CA2011: セッター内でプロパティを割り当てません](ca2011.md) | プロパティの [set アクセサー](../../../csharp/programming-guide/classes-and-structs/using-properties.md#the-set-accessor)内でプロパティに値が誤って割り当てられました。 |
> | [CA2012: ValueTask を正しく使用する必要があります](ca2012.md) | メンバーの呼び出しから返される ValueTask は、直接待機される必要があります。  ValueTask を複数回使用しようとするか、完了が判明する前に結果に直接アクセスしようとすると、例外または破損が発生する可能性があります。  このような ValueTask を無視することは、機能的なバグを示していることが多く、パフォーマンスを低下させる可能性があります。 |
> | [CA2013: 値の型と共に ReferenceEquals を使用しないでください](ca2013.md) | <xref:System.Object.ReferenceEquals%2A?displayProperty=fullName> を使用して値を比較するときに、objA と objB が値の型である場合、この 2 つは <xref:System.Object.ReferenceEquals%2A> メソッドに渡される前にボックス化されます。 つまり、objA と objB が同じ値の型のインスタンスを表している場合でも、<xref:System.Object.ReferenceEquals%2A> メソッドからは false が返されます。 |
> | [CA2014: ループ内で stackalloc を使用しません](ca2014.md) | stackalloc によって割り当てられたスタック領域は、現在のメソッド呼び出しの終了時にのみ解放されます。  これをループ内で使用すると、スタックが無限に増加し、最終的にスタック オーバーフロー状態が発生する可能性があります。 |
> | [CA2015: MemoryManager から派生した型にはファイナライザーを定義しません&lt;T&gt;](ca2015.md) | <xref:System.Buffers.MemoryManager%601> から派生した型にファイナライザーを追加すると、<xref:System.Span%601> によってまだ使用中のメモリが解放される可能性があります。 |
> | [CA2016:CancellationToken パラメーターを 1 つのメソッドに転送する](ca2016.md) | `CancellationToken` パラメーターを 1 つを取るメソッドに転送して操作のキャンセル通知が適切に伝達されるようにするか、または `CancellationToken.None` を明示的に渡して意図的にトークンを伝達しないことを指定します。 |
> | [CA2100:SQL クエリのセキュリティ脆弱性を確認](ca2100.md) | メソッドに渡された文字列引数から構築された文字列を使用して System.Data.IDbCommand.CommandText プロパティが設定されています。 この規則では、文字列引数にユーザー入力が含まれていることが想定されています。 ユーザー入力から構築された SQL コマンド文字列には、SQL 注入攻撃に対する脆弱性があります。 |
> |[CA2101: P/Invoke 文字列引数に対してマーシャリングを指定します](ca2101.md) | プラットフォーム呼び出しメンバーが、部分信頼の呼び出し元を許可し、文字列パラメーターを持ち、さらにその文字列を明示的にマーシャリングしていません。 これはセキュリティ上の脆弱性となる可能性があります。 |
> | [CA2109:表示するイベント ハンドラーを確認します](ca2109.md) | パブリックまたはプロテクトのイベント ハンドラー メソッドが検出されました。 イベント ハンドラー メソッドは、絶対に必要な場合を除き公開しないでください。 |
> | [CA2119:プライベート インターフェイスを満たすメソッドをシールします](ca2119.md) | 継承可能なパブリック型により、internal (Visual Basic では Friend) インターフェイスのオーバーライド可能なメソッド実装が提供されます。 この規則違反を修正するには、アセンブリの外側でメソッドがオーバーライドされないようにします。 |
> |[CA2153: 破損状態例外の処理を回避します](ca2153.md) | 破損状態例外 (CSE) は、メモリの破損がプロセス内に存在していることを示します。 プロセスをクラッシュさせるのではなくこれらの例外をキャッチすることは、攻撃者が破損したメモリ領域にセキュリティ上の弱点を見出すことができた場合に、セキュリティ上の脆弱性となる可能性があります。 |
> | [CA2200:スタック詳細を保持するために再度スローします](ca2200.md) | 例外が再スローされ、その例外が throw ステートメントで明示的に指定されています。 throw ステートメントで例外を指定して例外が再スローされると、例外をスローした元のメソッドと現在のメソッドの間で呼び出されたメソッドの一覧は失われます。 |
> | [CA2201:予約された例外の種類を発生させません](ca2201.md) | これにより、元のエラーの検出およびデバッグが困難になります。 |
> | [CA2207:値型のスタティック フィールドのインラインを初期化します](ca2207.md) | 値型で明示的な静的コンストラクターを宣言しています。 この規則違反を修正するには、静的データが宣言されたとき、および静的コンストラクターを削除するときに、静的データをすべて初期化します。 |
> |[CA2208:引数の例外を正しくインスタンス化します](ca2208.md) | ArgumentException またはそのクラスから派生した例外の種類の既定 (パラメーターなし) のコンストラクターに対して呼び出しが行われたか、ArgumentException またはそのクラスから派生した例外の種類のパラメーター付きのコンストラクターに不適切な文字列型の引数が渡されました。 |
> |[CA2211:非定数フィールドは表示されません](ca2211.md) | 定数でも読み取り専用でもない静的フィールドは、スレッド セーフではありません。 このようなフィールドへのアクセスは、慎重に制御してください。また、クラス オブジェクトへのアクセスを同期するには、高度なプログラミング技術が必要です。 |
> | [CA2213:破棄可能なフィールドは破棄されなければなりません](ca2213.md) | System.IDisposable を実装する型が、IDisposable も実装する型を持つフィールドを宣言しています。 このフィールドの Dispose メソッドは、宣言している型の Dispose メソッドから呼び出されていません。 |
> | [CA2214:コンストラクターのオーバーライド可能なメソッドを呼び出しません](ca2214.md) | コンストラクターから仮想メソッドを呼び出すと、メソッドを呼び出すインスタンスのコンストラクターが実行されないことがあります。 |
> | [CA2215:Dispose メソッドが基底クラスの Dispose を呼び出す必要があります](ca2215.md) | 型が、破棄できる型から継承している場合、使用している Dispose メソッド内から基本型の Dispose メソッドを呼び出す必要があります。 |
> |[CA2216:破棄可能な型はファイナライザーを宣言しなければなりません](ca2216.md) | System.IDisposable を実装し、アンマネージ リソースの使用を提案するフィールドが含まれる型が、Object.Finalize で記述されているようにファイナライザーを実装していません。 |
> | [CA2218:オーバーライドする Equals で GetHashCode をオーバーライドします](ca2218.md) | パブリック型で <xref:System.Object.Equals%2A?displayProperty=fullName> をオーバーライドしていますが、<xref:System.Object.GetHashCode%2A?displayProperty=fullName> をオーバーライドしていません。 |
> | [CA2217:列挙型を FlagsAttribute に設定しません](ca2217.md) | 外部から参照できる列挙型が FlagsAttribute でマークされ、その列挙型に、2 の累乗でもなく、その列挙型で定義されている他の値の組み合わせでもない値が 1 つ以上含まれています。 |
> | [CA2219:exception 句に例外を発生させないでください](ca2219.md) | finally 句または fault 句で例外が発生すると、アクティブな例外が新しい例外によって隠されます。 filter 句で例外が発生すると、ランタイムがその例外を暗黙的にキャッチします。 これにより、元のエラーの検出およびデバッグが困難になります。 |
> | [CA2224:オーバーロードする演算子 equals で Equals をオーバーライドします](ca2224.md) | パブリック型で等値演算子が実装されていますが、<xref:System.Object.Equals%2A?displayProperty=fullName> がオーバーライドされていません。 |
> | [CA2225:演算子オーバーロードには名前付けされた代替が存在します](ca2225.md) |演算子のオーバーロードが検出され、予想される名前の代替メソッドが検出されませんでした。 名前付きの代替メンバーによって、演算子と同じ機能へアクセスできるようになります。また、演算子のオーバーロードをサポートしていない言語でプログラミングする場合でも、その代替メンバーを使用できます。 |
> | [CA2226:演算子は対称型オーバーロードを含まなければなりません](ca2226.md) | 型で等値演算子または非等値演算子を実装し、逆の働きをする演算子を実装していません。 |
> |[CA2227:Collection プロパティは読み取り専用でなければなりません](ca2227.md) | 書き込み可能なコレクション プロパティにより、ユーザーはコレクションを異なるコレクションで置換できます。 読み取り専用プロパティは、コレクションを置換できないようにしますが、個別のメンバーが設定されることは回避できません。 |
> | [CA2229:シリアル化コンストラクターを実装します](ca2229.md) | この規則違反を修正するには、シリアル化コンストラクターを実装します。 シールされたクラスの場合、コンストラクターをプライベートにするか、プロテクトにします。 |
> | [CA2231:ValueType.Equals のオーバーライドで、演算子 equals をオーバーロードします](ca2231.md) | 値型は、Object.Equals をオーバーライドしていますが、等値演算子を実装していません。 |
> | [CA2234:文字列の代わりに System.Uri オブジェクトを渡します](ca2234.md) | "uri"、"URI"、"urn"、"URN"、"url"、または "URL" という名前を持つ文字列パラメーターが指定されているメソッドに対して、呼び出しが行われました。 そのメソッドの型宣言に対応するメソッドのオーバーロードが存在し、それに対して System.Uri パラメーターが指定されています。 |
> | [CA2235:すべてのシリアル化不可能なフィールドを設定します](ca2235.md) | シリアル化できない型のインスタンス フィールドが、シリアル化できる型で宣言されています。 |
> | [CA2237:ISerializable 型を SerializableAttribute に設定します](ca2237.md) | 型が共通言語ランタイムでシリアル化できると認識されるようにするには、型を SerializableAttribute 属性でマークする必要があります。型が ISerializable インターフェイスの実装を通じてカスタムのシリアル化ルーチンを使用している場合でも、マークする必要があります。 |
> | [CA2241:書式設定メソッドに正しい引数を提供](ca2241.md) | System.String.Format に渡される引数 format に、各オブジェクトの引数に対応する書式指定項目が含まれていません (その逆も考えられます)。 |
> |[CA2242:NaN に対して正しくテストします](ca2242.md) | この式が Single.Nan または Double.Nan に対して値をテストしています。 値をテストするには、Single.IsNan(Single) または Double.IsNan(Double) を使用します。 |
> |[CA2243:属性文字列リテラルは、正しく解析する必要があります](ca2243.md) | 属性のリテラル文字列パラメーターが URL、GUID、またはバージョンとして正しく解析されません。 |
> | [CA2244: インデックス付き要素の初期化を重複させません](ca2244.md) | オブジェクト初期化子に、定数インデックスが同じインデックス付き要素の初期化子が複数あります。 最後の初期化子を除くすべての初期化子は冗長です。 |
> | [CA2245: プロパティをそれ自体に割り当てません](ca2245.md) | プロパティが誤ってそれ自体に割り当てられました。 |
> | [CA2246: 同じステートメントにシンボルとそのメンバーを割り当てません](ca2246.md) | 同じステートメントでシンボルとそのメンバー、つまりフィールドまたはプロパティを代入することは推奨されていません。 メンバー アクセスが代入前のシンボルの古い値を使用するのか、このステートメントの代入からの新しい値を使用するのかが明確ではありません。 |
> | [CA2247: TaskCompletionSource コンストラクターに渡された引数は、TaskContinuationOptions 列挙型ではなく、TaskCreationOptions 列挙型にする必要があります](ca2247.md) | TaskCompletionSource には、基になるタスクを制御する TaskCreationOptions を使用するコンストラクターと、そのタスクに格納されているオブジェクトの状態を使用するコンストラクターがあります。  TaskCreationOptions の代わりに TaskContinuationOptions を誤って渡すと、呼び出しでオプションが状態として処理されます。 |
> | [CA2248: 正しい enum 引数を Enum.HasFlag に指定します](ca2248.md) | `HasFlag` メソッドに引数として渡された列挙型が呼び出し元の列挙型と異なります。 |
> | [CA2249:String.IndexOf の代わりに String.Contains を使用することを検討します](ca2249.md) | 部分文字列が存在するかどうかを確認するために結果を使用する `string.IndexOf` の呼び出しは、`string.Contains` で置き換えることができます。 |
> | [CA2300:安全ではないデシリアライザー BinaryFormatter を使用しないでください](ca2300.md) | 安全でない逆シリアライザーは、信頼されていないデータを逆シリアル化するときに脆弱です。 攻撃者がシリアル化されたデータを変更して予期されない型を追加し、悪意のある副作用を持つオブジェクトを挿入する可能性があります。 |
> | [CA2301:最初に BinaryFormatter.Binder を設定しないで BinaryFormatter.Deserialize を呼び出さないでください](ca2301.md) | 安全でない逆シリアライザーは、信頼されていないデータを逆シリアル化するときに脆弱です。 攻撃者がシリアル化されたデータを変更して予期されない型を追加し、悪意のある副作用を持つオブジェクトを挿入する可能性があります。 |
> | [CA2302:BinaryFormatter.Deserialize を呼び出す前に BinaryFormatter.Binder が設定されていることを確認します](ca2302.md) | 安全でない逆シリアライザーは、信頼されていないデータを逆シリアル化するときに脆弱です。 攻撃者がシリアル化されたデータを変更して予期されない型を追加し、悪意のある副作用を持つオブジェクトを挿入する可能性があります。 |
> | [CA2305:安全ではないデシリアライザー LosFormatter を使用しないでください](ca2305.md) | 安全でない逆シリアライザーは、信頼されていないデータを逆シリアル化するときに脆弱です。 攻撃者がシリアル化されたデータを変更して予期されない型を追加し、悪意のある副作用を持つオブジェクトを挿入する可能性があります。 |
> | [CA2310:安全ではないデシリアライザー NetDataContractSerializer を使用しないでください](ca2310.md) | 安全でない逆シリアライザーは、信頼されていないデータを逆シリアル化するときに脆弱です。 攻撃者がシリアル化されたデータを変更して予期されない型を追加し、悪意のある副作用を持つオブジェクトを挿入する可能性があります。 |
> | [CA2311:最初に NetDataContractSerializer.Binder を設定しないで逆シリアル化しないでください](ca2311.md) | 安全でない逆シリアライザーは、信頼されていないデータを逆シリアル化するときに脆弱です。 攻撃者がシリアル化されたデータを変更して予期されない型を追加し、悪意のある副作用を持つオブジェクトを挿入する可能性があります。 |
> | [CA2312:NetDataContractSerializer.Binder を設定してから逆シリアル化してください](ca2312.md) | 安全でない逆シリアライザーは、信頼されていないデータを逆シリアル化するときに脆弱です。 攻撃者がシリアル化されたデータを変更して予期されない型を追加し、悪意のある副作用を持つオブジェクトを挿入する可能性があります。 |
> | [CA2315:安全ではないデシリアライザー ObjectStateFormatter を使用しないでください](ca2315.md) | 安全でない逆シリアライザーは、信頼されていないデータを逆シリアル化するときに脆弱です。 攻撃者がシリアル化されたデータを変更して予期されない型を追加し、悪意のある副作用を持つオブジェクトを挿入する可能性があります。 |
> | [CA2321:SimpleTypeResolver を使って JavaScriptSerializer で逆シリアル化しないでください](ca2321.md) | 安全でない逆シリアライザーは、信頼されていないデータを逆シリアル化するときに脆弱です。 攻撃者がシリアル化されたデータを変更して予期されない型を追加し、悪意のある副作用を持つオブジェクトを挿入する可能性があります。 |
> | [CA2322:逆シリアル化する前に JavaScriptSerializer が SimpleTypeResolver によって初期化されていないことを確認してください](ca2322.md) | 安全でない逆シリアライザーは、信頼されていないデータを逆シリアル化するときに脆弱です。 攻撃者がシリアル化されたデータを変更して予期されない型を追加し、悪意のある副作用を持つオブジェクトを挿入する可能性があります。 |
> | [CA2326: None 以外の TypeNameHandling 値は使用しないでください](ca2326.md) | 安全でない逆シリアライザーは、信頼されていないデータを逆シリアル化するときに脆弱です。 攻撃者がシリアル化されたデータを変更して予期されない型を追加し、悪意のある副作用を持つオブジェクトを挿入する可能性があります。 |
> | [CA2327: 安全でない JsonSerializerSettings を使用しないでください](ca2327.md) | 安全でない逆シリアライザーは、信頼されていないデータを逆シリアル化するときに脆弱です。 攻撃者がシリアル化されたデータを変更して予期されない型を追加し、悪意のある副作用を持つオブジェクトを挿入する可能性があります。 |
> | [CA2328: JsonSerializerSettings が安全であることを確認してください](ca2328.md) | 安全でない逆シリアライザーは、信頼されていないデータを逆シリアル化するときに脆弱です。 攻撃者がシリアル化されたデータを変更して予期されない型を追加し、悪意のある副作用を持つオブジェクトを挿入する可能性があります。 |
> | [CA2329: セキュリティで保護されていない構成が JsonSerializer で使用されている場合は、逆シリアル化を行わないでください](ca2329.md) | 安全でない逆シリアライザーは、信頼されていないデータを逆シリアル化するときに脆弱です。 攻撃者がシリアル化されたデータを変更して予期されない型を追加し、悪意のある副作用を持つオブジェクトを挿入する可能性があります。 |
> | [CA2330: 逆シリアル化の際に、JsonSerializer の構成は確実にセキュリティで保護してください](ca2330.md) | 安全でない逆シリアライザーは、信頼されていないデータを逆シリアル化するときに脆弱です。 攻撃者がシリアル化されたデータを変更して予期されない型を追加し、悪意のある副作用を持つオブジェクトを挿入する可能性があります。 |
> | [CA2350:DataTable.ReadXml() の入力が信頼されていることを確認してください](ca2350.md) | 信頼されていない入力を使用して <xref:System.Data.DataTable> を逆シリアル化すると、攻撃者が悪意のある入力を作成してサービス拒否攻撃を仕掛ける可能性があります。 リモート コード実行の不明な脆弱性が存在する可能性があります。 |
> | [CA2351:DataSet.ReadXml() の入力が信頼されていることを確認してください](ca2351.md) | 信頼されていない入力を使用して <xref:System.Data.DataSet> を逆シリアル化すると、攻撃者が悪意のある入力を作成してサービス拒否攻撃を仕掛ける可能性があります。 リモート コード実行の不明な脆弱性が存在する可能性があります。 |
> | [CA2352: シリアル化可能な型の安全でない DataSet または DataTable は、リモート コード実行攻撃に対して脆弱になる可能性があります](ca2352.md) | <xref:System.SerializableAttribute> でマークされたクラスまたは構造体に <xref:System.Data.DataSet> または <xref:System.Data.DataTable> フィールドまたはプロパティは含まれていますが、<xref:System.CodeDom.Compiler.GeneratedCodeAttribute> はありません。 |
> | [CA2353: シリアル化可能な型の安全でない DataSet または DataTable](ca2353.md) | XML シリアル化属性またはデータ コントラクト属性でマークされたクラスまたは構造体に、<xref:System.Data.DataSet> または <xref:System.Data.DataTable> フィールドまたはプロパティが含まれています。 |
> | [CA2354:逆シリアル化されたオブジェクト グラフの安全でない DataSet または DataTable は、リモート コード実行攻撃に対して脆弱になる可能性があります](ca2354.md) | <xref:System.Runtime.Serialization.IFormatter?displayProperty=nameWithType> シリアル化で逆シリアル化し、キャストされた型のオブジェクト グラフに <xref:System.Data.DataSet> または <xref:System.Data.DataTable> を含んでいる可能性があります。 |
> | [CA2355:逆シリアル化されたオブジェクト グラフの安全でない DataSet または DataTable](ca2355.md) | キャストされたまたは指定された型のオブジェクト グラフに <xref:System.Data.DataSet> または <xref:System.Data.DataTable> を含んでいる可能性があるときに逆シリアル化しています。 |
> | [CA2356: Web の逆シリアル化されたオブジェクト グラフの安全でない DataSet または DataTable](ca2356.md) | <xref:System.Web.Services.WebMethodAttribute?displayProperty=nameWithType> または <xref:System.ServiceModel.OperationContractAttribute?displayProperty=nameWithType> を持つメソッドに、<xref:System.Data.DataSet> または <xref:System.Data.DataTable> を参照する可能性があるパラメーターがあります。 |
> | [CA2361: DataSet.ReadXml() を含む自動生成クラスが信頼されていないデータで使用されていないことを確認してください](ca2361.md) | 信頼されていない入力を使用して <xref:System.Data.DataSet> を逆シリアル化すると、攻撃者が悪意のある入力を作成してサービス拒否攻撃を仕掛ける可能性があります。 リモート コード実行の不明な脆弱性が存在する可能性があります。 |
> | [CA2362: シリアル化可能な自動生成型の安全でない DataSet または DataTable は、リモート コード実行攻撃に対して脆弱になる可能性があります](ca2362.md) | <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> で信頼されていない入力を逆シリアル化し、逆シリアル化されたオブジェクト グラフに <xref:System.Data.DataSet> または <xref:System.Data.DataTable> が含まれている場合、攻撃者が悪意のあるペイロードを作成して、リモート コード実行攻撃を仕掛ける可能性があります。 |
> | [CA3001:SQL インジェクションの脆弱性のコード レビュー](ca3001.md) | 信頼されていない入力と SQL コマンドを処理するときには、SQL インジェクション攻撃に注意してください。 SQL インジェクション攻撃では、悪意のある SQL コマンドが実行され、アプリケーションのセキュリティと整合性が損なわれる可能性があります。 |
> | [CA3002:XSS の脆弱性のコード レビュー](ca3002.md) | Web 要求からの信頼されていない入力を処理するときには、クロスサイト スクリプティング (XSS) 攻撃に注意してください。 XSS 攻撃によって信頼されていない入力が未加工の HTML 出力に挿入され、攻撃者が悪意のあるスクリプトを実行するか、Web ページのコンテンツを故意に変更できるようになります。 |
> | [CA3003:ファイル パス インジェクションの脆弱性のコード レビュー](ca3003.md) | Web 要求からの信頼されていない入力を処理するときには、ユーザー制御の入力の使用に注意してください。 |
> | [CA3004:情報漏えいの脆弱性のコード レビュー](ca3004.md) | 例外情報を公開すると、攻撃者はアプリケーションの内部に関する分析情報を入手して、悪用できる他の脆弱性を見つけることができます。 |
> | [CA3006:プロセス コマンド インジェクションの脆弱性のコード レビュー](ca3006.md) | 信頼されていない入力を処理するときには、コマンド インジェクション攻撃に注意してください。 コマンド インジェクション攻撃では、基になるオペレーティング システムに対して悪意のあるコマンドが実行され、サーバーのセキュリティと整合性が損なわれる可能性があります。 |
> | [CA3007:オープン リダイレクトの脆弱性のコード レビュー](ca3007.md) | 信頼されていない入力を処理するときには、オープン リダイレクトの脆弱性に注意してください。 攻撃者はオープン リダイレクトの脆弱性を悪用し、Web サイトを利用して正規の URL を表し、疑っていない訪問者をフィッシングなどの悪意のある Web ページにリダイレクトできます。 |
> | [CA3008:XPath インジェクションの脆弱性のコード レビュー](ca3008.md) | 信頼されていない入力を処理するときには、XPath インジェクション攻撃に注意してください。 信頼されていない入力を使用して XPath クエリを作成すると、攻撃者がクエリを操作して意図しない結果を返したり、クエリ対象の XML のコンテンツを開示したりする可能性があります。 |
> | [CA3009:XML インジェクションの脆弱性のコード レビュー](ca3009.md) | 信頼されていない入力を処理するときには、XML インジェクション攻撃に注意してください。 |
> | [CA3010:XAML インジェクションの脆弱性のコード レビュー](ca3010.md) | 信頼されていない入力を処理するときには、XAML インジェクション攻撃に注意してください。 XAML は、オブジェクトのインスタンス化と実行を直接表すマークアップ言語です。 つまり、XAML に作成された要素とシステム リソース (ネットワーク アクセス、ファイル システム IO など) の間でやり取りできます。 |
> | [CA3011:DLL インジェクションの脆弱性のコード レビュー](ca3011.md) | 信頼できない入力を処理するときには、信頼されていないコードの読み込みに注意してください。 Web アプリケーションで信頼されていないコードを読み込むと、攻撃者が悪意のある DLL をプロセスに挿入し、悪意のあるコードを実行できる可能性があります。 |
> | [CA3012:RegEx インジェクションの脆弱性のコード レビュー](ca3012.md) | 信頼されていない入力を処理するときには、正規表現インジェクション攻撃に注意してください。 攻撃者は、正規表現インジェクションを使用して正規表現を故意に変更したり、正規表現を意図しない結果と一致させたりする可能性があります。また、正規表現によって CPU を過度に消費し、サービス拒否攻撃を行う可能性もあります。 |
> | [CA3061:URL でスキーマを追加しません](ca3061.md) | 危険な外部参照を引き起こす可能性があるため、Add メソッドの安全でないオーバーロードは使用しないでください。 |
> | [CA3075:安全ではない DTD の処理](ca3075.md) | 安全ではない DTDProcessing インスタンスを使用する場合、または外部エンティティ ソースを参照する場合、パーサーは信頼されていない入力を受け入れ、攻撃者に機密情報を漏えいしてしまう可能性があります。 |
> | [CA3076:安全ではない XSLT スクリプトの実行](ca3076.md) | .NET アプリケーションで XSLT (Extensible Stylesheet Language Transformation) を安全ではない方法で実行すると、攻撃者に機密情報を漏えいする可能性のある、信頼されていない URI 参照がプロセッサにより解決されるおそれがあります。そのことは、サービス拒否攻撃やクロスサイト攻撃につながります。 |
> | [CA3077:API のデザイン、XML ドキュメント、および XML テキスト リーダーでの安全ではない処理](ca3077.md) | XMLDocument と XMLTextReader から派生する API をデザインする場合、DtdProcessing にご注意ください。 外部エンティティ ソースを参照または解決したり、XML に安全ではない値を設定したりする場合に、安全ではない DTDProcessing インスタンスを使用すると、情報漏えいにつながる可能性があります。 |
> | [CA3147:ValidateAntiForgeryToken で動詞ハンドラーをマークします](ca3147.md) | ASP.NET MVC コントローラーを設計するときには、クロスサイト リクエスト フォージェリ攻撃に注意してください。 クロスサイト リクエスト フォージェリ攻撃では、認証されたユーザーから ASP.NET MVC コントローラーに悪意のある要求が送信される可能性があります。 |
> | [CA5350:脆弱な暗号アルゴリズムを使用しないでください](ca5350.md) | 現在、さまざまな理由で弱い暗号化アルゴリズムとハッシュ関数が使用されていますが、保護対象のデータの機密性や整合性を保証するためにこれらを使用しないでください。 このルールは、コードで TripleDES、SHA1、または RIPEMD160 アルゴリズムが検出されるとトリガーされます。|
> | [CA5351 破られた暗号アルゴリズムを使用しないでください](ca5351.md) | 破られた暗号アルゴリズムはセキュアであるとは見なされず、それらを使用しないことを強くお勧めします。 このルールは、コードに MD5 ハッシュ アルゴリズムや、DES か RC2 のいずれかの暗号化アルゴリズムが検出されるとトリガーされます。 |
> | [CA5358:安全ではない暗号モードを使用しないでください](ca5358.md) | 安全ではない暗号モードを使用しないでください |
> | [CA5359 証明書の検証を無効にしません](ca5359.md) | 証明書を使用すると、サーバーの ID を認証できます。 クライアントでは、サーバー証明書を検証し、要求が意図したとおりのサーバーに送信されるようにする必要があります。 ServerCertificateValidationCallback によって常に `true` が返されると、すべての証明書が検証に成功します。 |
> | [CA5360 逆シリアル化で危険なメソッドを呼び出しません](ca5360.md) | 安全でない逆シリアル化は、信頼されていないデータを使用してアプリケーションのロジックが悪用されたり、サービス拒否 (DoS) 攻撃が仕掛けられたり、逆シリアル化されたときに任意のコードが実行されたりするときに発生する脆弱性です。 悪意のあるユーザーが自分の管理下にある信頼されていないデータをアプリケーションで逆シリアル化しているときに、これらの逆シリアル化機能を悪用することがよくあります。 具体的には、逆シリアル化の過程で危険なメソッドを呼び出します。 安全でない逆シリアル化攻撃が成功すると、攻撃者は DoS 攻撃、認証回避、リモートでのコード実行などの攻撃を仕掛ける可能性があります。 |
> | [CA5361: 強力な暗号の Schannel の使用を無効にしません](ca5361.md) | `Switch.System.Net.DontEnableSchUseStrongCrypto` を `true` に設定すると、送信トランスポート層セキュリティ (TLS) 接続で使用される暗号が弱くなります。 暗号が弱くなると、アプリケーションとサーバー間の通信の機密性が損なわれ、攻撃者が機密データを簡単に傍受できるようになります。 |
> | [CA5362: 逆シリアル化されたオブジェクト グラフで可能性のある参照サイクル](ca5362.md) | 信頼されていないデータを逆シリアル化すると、逆シリアル化されたオブジェクト グラフを処理するすべてのコードで、無限ループに入ることなく参照サイクルを処理する必要があります。 これには、逆シリアル化コールバックの一部であるコードと、逆シリアル化が完了した後にオブジェクト グラフを処理するコードの両方が含まれます。 そうしないと、攻撃者が参照サイクルを含む悪意のあるデータを使用してサービス拒否攻撃を仕掛ける可能性があります。 |
> | [CA5363:要求の検証を無効にしません](ca5363.md) | 要求の検証は、ASP.NET の機能の 1 つで、HTTP 要求を調べ、その要求にクロスサイトスクリプティングを含むインジェクション攻撃につながる可能性のある危険なコンテンツが含まれていないかどうかを確認します。 |
> | [CA5364: 非推奨のセキュリティ プロトコルを使用しないでください](ca5364.md) | トランスポート層セキュリティ (TLS) では、コンピューター間の通信を保護し、ハイパーテキスト転送プロトコル セキュア (HTTPS) とよく併用されます。 TLS の古いプロトコル バージョンは TLS 1.2 や TLS 1.3 よりも安全性が低く、新しい脆弱性が見つかる可能性が高くなります。 リスクを最小限に抑えるために、古いプロトコル バージョンを使用しないようにしてください。 |
> | [CA5365: HTTP ヘッダーのチェックを無効にしません](ca5365.md) | HTTP ヘッダーのチェックでは、応答ヘッダーに含まれる復帰 \r や改行文字 \n のエンコードを有効にします。 このエンコードは、ヘッダーに含まれる信頼されていないデータをエコーするアプリケーションを悪用するインジェクション攻撃を回避するのに役立ちます。 |
> | [CA5366: DataSet Read XML に XmlReader を使用します](ca5366.md) | <xref:System.Data.DataSet> を使用して信頼されていないデータを含んだ XML を読み取ると、危険な外部参照が読み込まれる可能性があります。<xref:System.Xml.XmlReader> を安全なリゾルバーと共に使用するか、DTD 処理を無効にして使用することにより、この処理を制限する必要があります。 |
> | [CA5367: ポインター フィールドを持つ型をシリアル化しません](ca5367.md) | この規則では、ポインター フィールドまたはプロパティを持つシリアル化可能なクラスがあるかどうかをチェックします。 静的メンバー、<xref:System.NonSerializedAttribute> でマークされたフィールドなど、シリアル化できないメンバーがポインターになる可能性があります。 |
> | [CA5368: ページから派生したクラスに ViewStateUserKey を設定します](ca5368.md) | <xref:System.Web.UI.Page.ViewStateUserKey> プロパティを設定すると、識別子を個別のユーザーの view-state 変数に割り当てて、攻撃者が変数を使用した攻撃を実行できないようにすることで、アプリケーションに対する攻撃を防ぐことができます。 そうしない場合、クロスサイト リクエスト フォージェリに対する脆弱性が生じます。 |
> | [CA5369:逆シリアル化に XmlReader を使用します](ca5369.md) | 信頼されていない DTD と XML スキーマを処理すると、危険な外部参照を読み込むことができる可能性があります。XmlReader を安全なリゾルバーと共に使用するか、DTD と XML インライン スキーマ処理を無効にして使用することにより、この処理を制限する必要があります。 |
> | [CA5370:読み取りの検証に XmlReader を使用します](ca5370.md) | 信頼されていない DTD と XML スキーマを処理すると、危険な外部参照を読み込むことができる可能性があります。 この危険な読み込みは、XmlReader を安全なリゾルバーと共に使用するか、DTD と XML インライン スキーマ処理を無効にして使用することにより制限する必要があります。 |
> | [CA5371:スキーマの読み取りに XmlReader を使用します](ca5371.md) | 信頼されていない DTD と XML スキーマを処理すると、危険な外部参照を読み込むことができる可能性があります。 XmlReader を安全なリゾルバーと共に使用するか、DTD と XML インライン スキーマ処理を無効にして使用することにより、この処理を制限します。 |
> | [CA5372:XPathDocument に XmlReader を使用します](ca5372.md) | 信頼されていないデータから XML を処理すると、危険な外部参照を読み込む可能性があります。XmlReader を安全なリゾルバーと共に使用するか、DTD 処理を無効にして使用することにより、この処理を制限できます。 |
> | [CA5373:廃止されたキー派生関数を使用しません](ca5373.md) | この規則では、弱いキー派生メソッド <xref:System.Security.Cryptography.PasswordDeriveBytes?displayProperty=fullName> と `Rfc2898DeriveBytes.CryptDeriveKey` の呼び出しを検出します。 <xref:System.Security.Cryptography.PasswordDeriveBytes?displayProperty=fullName> で弱いアルゴリズム PBKDF1 が使用されました。 |
> | [CA5374: XslTransform を使用しません](ca5374.md) | この規則では、<xref:System.Xml.Xsl.XslTransform?displayProperty=nameWithType> がコードでインスタンス化されるかどうかをチェックします。 <xref:System.Xml.Xsl.XslTransform?displayProperty=nameWithType> は古いため、使用しないでください。 |
> | [CA5375: アカウントの Shared Access Signature を使用しません](ca5375.md) | アカウントの SAS では、サービス SAS で許可されていない BLOB コンテナー、テーブル、キューおよびファイル共有の読み取り、書き込みおよび削除操作へのアクセスを委任できます。 ただし、コンテナーレベルのポリシーをサポートしておらず、付与されるアクセス許可に対する柔軟性と制御力は高くありません。 悪意のあるユーザーがアカウントの SAS を入手すると、ストレージ アカウントは簡単に侵害されます。 |
> | [CA5376: SharedAccessProtocol HttpsOnly を使用します](ca5376.md) | SAS は HTTP を介してプレーン テキストで転送できない機密データです。 |
> | [CA5377: コンテナー レベルのアクセス ポリシーを使用します](ca5377.md) | コンテナーレベルのアクセス ポリシーは、いつでも変更または取り消すことができます。 このため、付与されるアクセス許可をより柔軟に制御できます。 |
> | [CA5378: ServicePointManagerSecurityProtocols を無効にしません](ca5378.md) | `Switch.System.ServiceModel.DisableUsingServicePointManagerSecurityProtocols` を `true` に設定すると、Windows Communication Framework (WCF) のトランスポート層セキュリティ (TLS) 接続が TLS 1.0 に制限されます。 このバージョンの TLS は非推奨になる予定です。 |
> | [CA5379: 弱いキー派生関数アルゴリズムを使用しません](ca5379.md) | <xref:System.Security.Cryptography.Rfc2898DeriveBytes> クラスでは、既定で <xref:System.Security.Cryptography.HashAlgorithmName.SHA1> アルゴリズムを使用します。 <xref:System.Security.Cryptography.HashAlgorithmName.SHA256> またはそれ以上を使用して、コンストラクターの一部のオーバーロードで使用するハッシュ アルゴリズムを指定する必要があります。 ただし、<xref:System.Security.Cryptography.Rfc2898DeriveBytes.HashAlgorithm> プロパティには `get` アクセサーしかなく、`overriden` 修飾子はありません。 |
> | [CA5380:ルート ストアに証明書を追加しません](ca5380.md) | この規則では、証明書を信頼されたルート証明機関の証明書ストアに追加するコードを検出します。 既定では、信頼されたルート証明機関の証明書ストアは、Microsoft ルート証明書プログラムの要件を満たした一連の公的 CA で構成されています。 |
> | [CA5381:証明書がルート ストアに追加されていないことを確認します](ca5381.md) | この規則では、証明書を信頼されたルート証明機関の証明書ストアに追加する可能性があるコードを検出します。 既定では、信頼されたルート証明機関の証明書ストアは、Microsoft ルート証明書プログラムの要件を満たした一連の公的証明機関 (CA) で構成されています。 |
> | [CA5382: ASP.NET Core で安全な Cookie を使用します](ca5382.md) | HTTPS 経由で使用できるアプリケーションでは、セキュリティで保護された Cookie を使用する必要があります。つまり、Cookie は Secure Sockets Layer (SSL) のみを使用して転送する必要があることをブラウザーに示す必要があります。 |
> | [CA5383: ASP.NET Core で安全な Cookie を使用することを確認します](ca5383.md) | HTTPS 経由で使用できるアプリケーションでは、セキュリティで保護された Cookie を使用する必要があります。つまり、Cookie は Secure Sockets Layer (SSL) のみを使用して転送する必要があることをブラウザーに示す必要があります。 |
> | [CA5384: デジタル署名アルゴリズム (DSA) を使用しません](ca5384.md) | DSA は、弱い非対称暗号化アルゴリズムです。 |
> | [CA5385: 十分なキー サイズの Rivest–Shamir–Adleman (RSA) アルゴリズムを使用します](ca5385.md) | 2048 ビットよりも小さい RSA キーは、ブルート フォース攻撃に対する脆弱性が高くなります。 |
> | [CA5386: SecurityProtocolType 値のハードコードを避けます](ca5386.md) | トランスポート層セキュリティ (TLS) では、コンピューター間の通信を保護し、ハイパーテキスト転送プロトコル セキュア (HTTPS) とよく併用されます。 プロトコル バージョン TLS 1.0 と TLS 1.1 は非推奨で、TLS 1.2 と TLS 1.3 が現行のバージョンです。 今後、TLS 1.2 と TLS 1.3 も非推奨になる可能性があります。 アプリケーションをセキュリティで保護し続けるために、プロトコル バージョンをハードコーティングしないようにし、少なくとも .NET Framework v4.7.1 を対象にしてください。 |
> | [CA5387: 反復回数が十分でない弱いキー派生関数は使用しません](ca5387.md) | この規則では、反復回数が 100,000 回未満の <xref:System.Security.Cryptography.Rfc2898DeriveBytes> によって暗号化キーが生成されたかどうかをチェックします。 反復回数が多いほど、生成された暗号化キーを推測しようとする辞書攻撃を緩和するのに役立ちます。 |
> | [CA5388: 弱いキー派生関数を使用する場合は十分な反復回数を確保してください](ca5388.md) | この規則では、反復回数が 100,000 回未満の可能性がある <xref:System.Security.Cryptography.Rfc2898DeriveBytes> によって暗号化キーが生成されたかどうかをチェックします。 反復回数が多いほど、生成された暗号化キーを推測しようとする辞書攻撃を緩和するのに役立ちます。 |
> | [CA5389:アーカイブ項目のパスをターゲット ファイル システム パスに追加しません](ca5389.md) | ファイル パスは相対パスの場合があり、想定されるファイル システムのターゲット パス以外でファイル システムへのアクセスが可能になる可能性があります。これは、lay-and-wait の技法によって悪意のある構成変更とリモート コードの実行につながります。 |
> | [CA5390: 暗号化キーをハードコーディングしません](ca5390.md) | 対称アルゴリズムを成功させるには、送信側と受信側だけに秘密キーを伝える必要があります。 キーがハードコーディングされていると、簡単に検出できます。 コンパイルされたバイナリでも、悪意のあるユーザーが簡単に抽出できます。 秘密キーが侵害されると、暗号テキストを直接復号化できるようになるため、保護されていない状態になります。 |
> | [CA5391: ASP.NET Core MVC コントローラーで偽造防止トークンを使用します](ca5391.md) | 偽造防止トークンを検証せずに `POST`、`PUT`、`PATCH` または `DELETE` 要求を処理すると、クロスサイト リクエスト フォージェリ攻撃に対して脆弱になる可能性があります。 クロスサイト リクエスト フォージェリ攻撃では、認証されたユーザーから ASP.NET Core MVC コントローラーに悪意のある要求が送信される可能性があります。 |
> | [CA5392: P/Invoke に対して DefaultDllImportSearchPaths 属性を使用します](ca5392.md) | 既定では、<xref:System.Runtime.InteropServices.DllImportAttribute> を使用している P/Invoke 関数では、ライブラリが読み込むための現在の作業ディレクトリを含むいくつかのディレクトリを精査します。 これは特定のアプリケーションでセキュリティ上の問題を引き起こし、DLL のハイジャックにつながる可能性があります。 |
> | [CA5393: 安全でない DllImportSearchPath 値を使用しない](ca5393.md) | 既定の DLL 検索ディレクトリとアセンブリ ディレクトリに悪意のある DLL が存在する可能性があります。 または、アプリケーションが実行されている場所に応じて、アプリケーションのディレクトリに悪意のある DLL が存在する可能性があります。 |
> | [CA5394: 安全でないランダム度を使用しません](ca5394.md) | 暗号強度の低い擬似乱数ジェネレーターを使用すると、セキュリティ上注意が必要などのような値が生成されるかを攻撃者が予測できる可能性があります。 |
> | [CA5395 アクション メソッドの HttpVerb 属性がありません](ca5395.md) | データの作成、編集、削除、またはそれ以外の変更を行うすべてのアクション メソッドは、偽造防止属性を使用してクロスサイト リクエスト フォージェリ攻撃から保護する必要があります。 GET 操作の実行は、副作用がなく、永続化されたデータを変更しない、安全な操作である必要があります。 |
> | [CA5396: HttpCookie で HttpOnly を true に設定します](ca5396.md) | 高度な防御手段として、セキュリティ上注意が必要な HTTP Cookie が、必ず HttpOnly としてマークされるようにしてください。 これは、スクリプトから Cookie へのアクセスを Web ブラウザーで許可してはならないことを示しています。 挿入された悪意のあるスクリプトは、Cookie を盗むための一般的な方法です。 |
> | [CA5397:非推奨の SslProtocols 値を使用しません](ca5397.md) | トランスポート層セキュリティ (TLS) では、コンピューター間の通信を保護し、ハイパーテキスト転送プロトコル セキュア (HTTPS) とよく併用されます。 TLS の古いプロトコル バージョンは TLS 1.2 や TLS 1.3 よりも安全性が低く、新しい脆弱性が見つかる可能性が高くなります。 リスクを最小限に抑えるために、古いプロトコル バージョンを使用しないようにしてください。 |
> | [CA5398:ハードコーディングされた SslProtocols 値を回避します](ca5398.md) | トランスポート層セキュリティ (TLS) では、コンピューター間の通信を保護し、ハイパーテキスト転送プロトコル セキュア (HTTPS) とよく併用されます。 プロトコル バージョン TLS 1.0 と TLS 1.1 は非推奨で、TLS 1.2 と TLS 1.3 が現行のバージョンです。 今後、TLS 1.2 と TLS 1.3 も非推奨になる可能性があります。 アプリケーションをセキュリティで保護し続けるために、プロトコル バージョンをハードコーティングしないようにしてください。 |
> | [CA5399: HttpClient 証明書失効リストの確認を確実に無効にします](ca5399.md) | 失効した証明書は信頼されていません。 攻撃者が HTTPS 通信で悪意のあるデータを渡すか、機密データを盗むために使用する可能性があります。 |
> | [CA5400: HttpClient 証明書失効リストの確認が無効になっていないことをご確認ください](ca5400.md) | 失効した証明書は信頼されていません。 攻撃者が HTTPS 通信で悪意のあるデータを渡すか、機密データを盗むために使用する可能性があります。 |
> | [CA5401: 既定以外の IV で CreateEncryptor を使用しません](ca5401.md) | 対称暗号化では、辞書攻撃を防ぐために、反復不能な初期化ベクトルを常に使用する必要があります。 |
> | [CA5402: 既定の IV で CreateEncryptor を使用します](ca5402.md) | 対称暗号化では、辞書攻撃を防ぐために、反復不能な初期化ベクトルを常に使用する必要があります。 |
> | [CA5403:証明書をハードコーディングしない](ca5403.md) | <xref:System.Security.Cryptography.X509Certificates.X509Certificate> または <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> コンストラクターの `data` または `rawData` パラメーターがハードコーディングされています。 |
> | [IL3000: 単一ファイルとして発行するときにアセンブリ ファイル パスにアクセスしません](il3000.md) | 単一ファイルとして発行するときにアセンブリ ファイル パスにアクセスしないでください。 |
> | [IL3001: 単一ファイルとして発行するときにアセンブリ ファイル パスにアクセスしません](il3001.md) | 単一ファイルとして発行するときにアセンブリ ファイル パスにアクセスしないでください。 |

## <a name="legend"></a>凡例

次の表は、参照ドキュメントの各ルールについて提供されている情報の種類を示しています。

|項目|説明|
|----------|-----------------|
|種類|規則の TypeName。|
| **ルール ID** |規則の一意の識別子。 規則 ID とカテゴリは、ソース内で警告の省略表記として使用されます。|
| **カテゴリ** |規則のカテゴリ (たとえば、セキュリティ)。|
| **修正が中断ありか中断なしか** |規則違反を修正することが、互換性に影響する変更点かどうかを示します。 互換性に影響する変更点とは、違反の原因となった対象に対して依存関係を持つアセンブリが、新たに修正したバージョンで再コンパイルされないこと、または変更によって実行時にエラーになる可能性があることを示します。 複数の修正を適用でき、互換性に影響する変更点があるものとないものがある場合、"あり" と "なし" を併記しています。|
|原因|規則に従って警告が生成される原因になった特定のマネージド コード。|
|説明|警告の背景にある問題について説明します。|
|違反の修正方法|規則に適合し、警告が生成されないようにソース コードを変更する方法について説明します。|
|どのようなときに警告を抑制するか|規則による警告を抑制しても安全な場合について説明します。|
|コード例|規則に違反する例と、規則に適合する修正した例を示します。|
|関連規則|関連する規則。|
