---
title: サービス間通信
description: バックエンド クラウドネイティブ マイクロサービスが他のバックエンド マイクロサービスと通信する方法について説明します。
author: robvet
ms.date: 09/09/2019
ms.openlocfilehash: a5124b8b83f62ff17b1230ead63db26e0c1f2a5b
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/14/2020
ms.locfileid: "79401761"
---
# <a name="service-to-service-communication"></a>サービス間通信

[!INCLUDE [book-preview](../../../includes/book-preview.md)]

フロントエンド クライアントから移行し、バックエンド マイクロサービスが相互に通信する方法に対処するようになりました。

クラウド ネイティブ アプリケーションを構築する場合は、バックエンド サービスが相互に通信する方法に注意する必要があります。 理想的には、サービス間通信が少ないほど、より良い方法です。 ただし、バックエンド サービスは、多くの場合、操作を完了するために互いに依存しているので、回避は常に可能ではありません。

クロスサービス通信を実装するには、いくつかの広く受け入れられているアプローチがあります。 *コミュニケーションの相互作用のタイプ*は、多くの場合、最良のアプローチを決定します。

次の相互作用の種類を検討してください。

- *クエリ*– 呼び出し元のマイクロサービスが、"ねえ、特定の顧客 ID の購入者情報を与える" など、呼び出しマイクロサービスからの応答を必要とする場合。

- *Command* – 呼び出し元のマイクロサービスがアクションを実行するために別のマイクロサービスを必要としているが、応答を必要としない場合は、「ねえ、この注文を出荷するだけです。

- *イベント*– パブリッシャと呼ばれるマイクロサービスが、状態が変更されたか、アクションが発生したイベントを発生させるとします。 関心のあるサブスクライバーと呼ばれる他のマイクロサービスは、イベントに適切に対応できます。 パブリッシャーとサブスクライバーは、相互に認識していません。

マイクロサービス システムは、通常、サービス間の対話を必要とする操作を実行するときに、これらの相互作用の種類の組み合わせを使用します。 それぞれと実装方法を詳しく見ていきましょう。

## <a name="queries"></a>クエリ

多くの場合、あるマイクロサービスは別のマイクロサービスに*対してクエリ*を実行する必要があり、操作を完了するために即時の応答が必要になります。 買い物かごのマイクロサービスは、商品情報と商品をバスケットに追加するための価格を必要とする場合があります。 クエリ操作を実装するための方法は多数あります。

### <a name="requestresponse-messaging"></a>要求/応答メッセージング

このシナリオを実装する 1 つのオプションは、呼び出し側のバックエンド マイクロサービスが、クエリを実行する必要があるマイクロサービスに直接 HTTP 要求を作成することです (図 4-8 参照)。

![直接 HTTP 通信](./media/direct-http-communication.png)

**図 4-8**. 直接 HTTP 通信

マイクロサービス間の直接 HTTP 呼び出しは比較的簡単に実装できますが、この方法を最小限に抑える必要があります。 開始するには、これらの呼び出しは常に*同期*的であり、結果が返されるか、要求がタイムアウトになるまで操作をブロックします。 かつては自己完結型の独立したサービスで、独立して進化し、頻繁に展開することができ、今では互いに結びついています。 マイクロサービス間の結合が増加すると、アーキテクチャ上の利点は減少します。

一部のシステムでは、別のマイクロサービスに対して単一の直接 HTTP 呼び出しを行う頻度の低い要求を実行することが可能です。 ただし、複数のマイクロサービスに対して直接 HTTP 呼び出しを呼び出す大量呼び出しは推奨されません。 遅延が長くなり、システムのパフォーマンス、スケーラビリティ、および可用性に悪影響を及ぼす可能性があります。 さらに悪いことに、一連の直接的な HTTP 通信が長いと、同期マイクロサービス呼び出しの深く複雑なチェーンが生じる可能性があります (図 4-9 を参照)。

![HTTP クエリのチェーン](./media/chaining-http-queries.png)

**図 4-9**. HTTP クエリのチェーン

前の図に示したデザインのリスクは、確かに想像できます。 ステップ\#3 が失敗した場合はどうなりますか。 または、\#ステップ8が失敗しますか? どのように回復しますか? 基になるサービス\#がビジー状態であるために手順 6 が遅い場合はどうでしょうか。 どのように続けますか? すべての操作が正しく機能する場合でも、この呼び出しが発生する待機時間 (各ステップの待機時間の合計) を考えてください。

前の画像の結合度が大きい場合、サービスが最適にモデル化されていなかったことを示唆しています。 彼らのデザインを再検討するのはチームを後押しするだろう。

### <a name="materialized-view-pattern"></a>具体化されたビュー パターン

マイクロサービスカップリングを削除する一般的なオプションは、[マテリアライズビューパターン](https://docs.microsoft.com/azure/architecture/patterns/materialized-view)です。 このパターンでは、マイクロサービスは、他のサービスが所有するデータの独自のローカルで非正規化されたコピーを格納します。 ショッピング バスケット マイクロサービスが製品カタログおよび価格のマイクロサービスを照会する代わりに、そのデータの独自のローカル コピーを保持します。 このパターンは不要なカップリングを除去し、信頼性および応答時間を改善する。 操作全体が 1 つのプロセス内で実行されます。 第5章では、このパターンとその他のデータに関する問題について説明します。

### <a name="service-aggregator-pattern"></a>サービス アグリゲータ パターン

マイクロサービスとマイクロサービスの結合をなくすもう 1 つのオプションは、図 4-10 に紫色で示す[アグリゲータ マイクロサービス](https://devblogs.microsoft.com/cesardelatorre/designing-and-implementing-api-gateways-with-ocelot-in-a-microservices-and-container-based-architecture/)です。

![アグリゲーターサービス](./media/aggregator-service.png)

**図 4-10**. アグリゲーターマイクロサービス

このパターンは、複数のバックエンド マイクロサービスを呼び出す操作を分離し、そのロジックを特殊なマイクロサービスに集中させます。  前の図の紫色のチェックアウト アグリゲータ マイクロサービスは、チェックアウト操作のワークフローを調整します。 これには、シーケンス順で複数のバックエンド マイクロサービスへの呼び出しが含まれます。 ワークフローのデータが集約され、呼び出し元に返されます。 直接 HTTP 呼び出しを実装する間も、アグリゲーター マイクロサービスはバックエンド マイクロサービス間の直接的な依存関係を減らします。

### <a name="requestreply-pattern"></a>要求/応答パターン

同期 HTTP メッセージを分離するもう 1 つの方法は、キューイング通信を使用する[要求応答パターン](https://www.enterpriseintegrationpatterns.com/patterns/messaging/RequestReply.html)です。 キューを使用した通信は常に一方向のチャネルであり、プロデューサがメッセージを送信し、コンシューマがそれを受信します。 このパターンでは、図 4-11 に示すように、要求キューと応答キューの両方が実装されます。

![要求/応答パターン](./media/request-reply-pattern.png)

**図 4-11**. 要求/応答パターン

ここでは、メッセージ プロデューサーは、一意の相関 ID を含むクエリ ベースのメッセージを作成し、要求キューに配置します。 使用サービスは、メッセージをキューから取り出し、処理し、応答を同じ相関 ID を持つ応答キューに入れます。 プロデューサ サービスは、メッセージをキューから取り出し、相関 ID と照合して処理を続行します。 キューについては、次のセクションで詳しく説明します。

## <a name="commands"></a>コマンド

もう 1 つの通信の種類は *、 コマンド*です。 マイクロサービスでは、アクションを実行するために別のマイクロサービスが必要になる場合があります。 注文マイクロサービスでは、承認された注文の出荷を作成するために出荷マイクロサービスが必要な場合があります。 図 4-12 では、プロデューサーと呼ばれる 1 つのマイクロサービスが、別のマイクロサービスである Consumer にメッセージを送信し、何かを実行するように命令します。

![キューとのコマンド操作](./media/command-interaction-with-queue.png)

**図 4-12**. キューとのコマンド操作

ほとんどの場合、プロデューサーは応答を必要とせず、メッセージを*起動して忘*れることができます。 応答が必要な場合、コンシューマーは別のチャネルのプロデューサーに別のメッセージを送り返します。 コマンド メッセージは、メッセージ キューと共に非同期的に送信するのが最適です。 軽量のメッセージ ブローカーでサポートされています。 前の図では、キューが両方のサービスを分離および切り離す方法に注意してください。

メッセージ キューは、プロデューサとコンシューマがメッセージを渡す仲介構造です。 キューは、非同期のポイント ツー ポイント メッセージング パターンを実装します。 プロデューサーは、コマンドの送信先を知り、適切にルーティングします。 キューは、チャネルから読み取るコンシューマー インスタンスの 1 つだけによってメッセージが処理されることを保証します。 このシナリオでは、プロデューサ またはコンシューマー サービスは、他のサービスに影響を与えずにスケール アウトできます。 また、テクノロジはそれぞれの側面で異なる場合があるため[、Golang](https://golang.org)マイクロサービスを呼び出す Java マイクロサービスが発生する可能性があります。

第1章では、*バッキングサービス*について話しました。 バッキング サービスは、クラウド ネイティブ システムが依存する補助的なリソースです。 メッセージ キューは、サービスをバッキングしています。 Azure クラウドでは、コマンド メッセージングを実装するためにクラウド ネイティブ システムが使用できる 2 種類のメッセージ キュー (Azure Storage キューと Azure Service Bus キュー) がサポートされています。

### <a name="azure-storage-queues"></a>Azure Storage キュー

Azure ストレージ キューは、Azure ストレージ アカウントによって、高速で手頃な価格で、バックアップされたシンプルなキューイング インフラストラクチャを提供します。

[Azure Storage キューには、](https://docs.microsoft.com/azure/storage/queues/storage-queues-introduction)信頼性の高い永続的なメッセージングを備えた REST ベースのキューイング メカニズムが備えられています。 最小限の機能セットを提供しますが、安価で、数百万のメッセージを保存します。 容量は最大500 TBです。 1 つのメッセージのサイズは最大 64 KB です。

HTTP または HTTPS を使用して、認証された呼び出しを介して世界中のどこからでもメッセージにアクセスできます。 ストレージ キューは、トラフィックの急増に対処するために、多数の同時クライアントにスケール アウトできます。

つまり、サービスには次の制限があります。

- メッセージの順序は保証されません。

- メッセージは、自動的に削除されるまで 7 日間のみ保持できます。

- 状態管理、重複データ検出、またはトランザクションのサポートは利用できません。

図 4-13 は、Azure ストレージ キューの階層を示しています。

![ストレージ キュー階層](./media/storage-queue-hierarchy.png)

**図 4-13**. ストレージ キュー階層

前の図では、ストレージ キューが基になる Azure ストレージ アカウントにメッセージを格納する方法に注意してください。

開発者向けに、Microsoft はストレージ キュー処理用にクライアントおよびサーバー側のライブラリを複数提供しています。 ほとんどの主要なプラットフォームは、.NET、Java、JavaScript、ルビー、Python、および囲碁を含むサポートされています。 開発者は、これらのライブラリと直接通信しないでください。 これを行うと、マイクロサービス コードが Azure Storage キュー サービスに緊密に結合されます。 API の実装の詳細を絶縁する方が良い方法です。 一般的な操作を公開し、具象ライブラリをカプセル化する仲介レイヤー (中間 API) を導入します。 この疎結合により、メインライン・サービス・コードを変更することなく、あるキューイング・サービスを別のキューイング・サービスとスワップアウトできます。

Azure Storage キューは、クラウド ネイティブ アプリケーションにコマンド メッセージングを実装するための経済的なオプションです。 キュー サイズが 80 GB を超える場合、または単純な機能セットが許容される場合は特に問題ありません。 メッセージの保存に対してのみ支払う必要があります。固定時間料金はありません。

### <a name="azure-service-bus-queues"></a>Azure Service Bus キュー

より複雑なメッセージング要件については、Azure サービス バス のキューを検討してください。

堅牢なメッセージ インフラストラクチャの上に置き[、Azure Service Bus](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-messaging-overview)は*仲介メッセージング モデルを*サポートしています。 メッセージは、コンシューマが受信するまで、ブローカー (キュー) に確実に格納されます。 キューは、メッセージがキューに追加された順序を考慮して、先入れ先出し (FIFO) メッセージの配信を保証します。

メッセージのサイズは、最大 256 KB まで、はるかに大きくなる可能性があります。 メッセージは、キューに無制限に保持されます。 Service Bus は HTTP ベースの呼び出しだけでなく[、AMPQ プロトコル](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-amqp-overview)の完全なサポートも提供します。 AMPQ は、バイナリ プロトコルと高い信頼性をサポートするベンダー間のオープンスタンダードです。

Service Bus には、[トランザクション サポート](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-transactions)や[重複データ検出機能](https://docs.microsoft.com/azure/service-bus-messaging/duplicate-detection)など、豊富な機能が用意されています。 キューは、メッセージごとに 「1 回の配信」を保証します。 既に送信されたメッセージは自動的に破棄されます。 プロデューサが疑わしい場合は、同じメッセージを再送信することができ、Service Bus は 1 つのコピーのみが処理されることを保証します。 重複データ検出により、追加のインフラストラクチャ配管を構築する必要が少ないです。

さらに 2 つのエンタープライズ機能は、パーティション分割とセッションです。 従来の Service Bus キューは、単一のメッセージ ブローカーによって処理され、単一のメッセージ ストアに格納されます。 ただし[、Service Bus パーティション分割](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-partitioning)は、複数のメッセージ ブローカーとメッセージ ストアにキューを分散します。 単一のメッセージ ブローカーまたはメッセージング ストアのパフォーマンスによって、全体的なスループットが制限されなくなりました。 メッセージング ストアの一時的な停止では、パーティション分割されたキューが使用できなくなります。

[サービス バス セッションは](https://codingcanvas.com/azure-service-bus-sessions/)、グループ関連のメッセージを提供します。 メッセージを一緒に処理し、最後に操作を完了するワークフロー シナリオを想像してみてください。 利点を活かすには、キューに対してセッションを明示的に有効にし、関連する各メッセージに同じセッション ID を含める必要があります。

ただし、サービス バスキューのサイズは 80 GB に制限されており、ストア キューから入手できるサイズよりもはるかに小さい点に注意してください。 さらに、Service Bus キューには、運用ごとに基本コストと料金が発生します。

図 4-14 は、Service Bus キューの高レベル アーキテクチャの概要を示しています。

![Service Bus キュー](./media/service-bus-queue.png)

**図 4-14**.  Service Bus キュー

前の図では、ポイントツーポイントの関係に注意してください。 同じプロバイダーの 2 つのインスタンスが、メッセージを 1 つの Service Bus キューにキューイングしています。 各メッセージは、右側の 3 つのコンシューマー インスタンスのうち 1 つだけによって使用されます。 次に、異なるコンシューマが同じメッセージに関心を持つメッセージングを実装する方法について説明します。

## <a name="events"></a>events

メッセージ キューイングは、プロデューサがコンシューマにメッセージを非同期的に送信できる通信を実装する効果的な方法です。 しかし、*多くの異なる消費者*が同じメッセージに興味を持っている場合はどうなりますか? 各コンシューマーの専用メッセージ キューは、適切にスケーリングされず、管理が困難になります。

このシナリオに対処するために、3 番目の種類のメッセージ対話に移*ります*。 あるマイクロサービスは、アクションが発生したことをアナウンスします。 他のマイクロサービスは、関心がある場合は、アクションまたはイベントに反応します。

イベント処理は 2 段階のプロセスです。 特定の状態変更に関して、マイクロサービスはイベントをメッセージ ブローカーに発行し、他の関心のあるマイクロサービスで利用できるようにします。 関心のあるマイクロサービスは、メッセージ ブローカーでイベントをサブスクライブすることによって通知されます。 [パブリッシュ/サブスクライブ](https://docs.microsoft.com/azure/architecture/patterns/publisher-subscriber)パターンを使用して[、イベントベースの通信](https://docs.microsoft.com/dotnet/standard/microservices-architecture/multi-container-microservice-net-applications/integration-event-based-microservice-communications)を実装します。

図 4-15 は、他の 2 つのマイクロサービスがサブスクライブしているイベントを公開するショッピング バスケット マイクロサービスを示しています。

![イベント駆動型メッセージング](./media/event-driven-messaging.png)

**図 4-15**.  イベント駆動型メッセージング

通信チャネルの中央に位置する*イベント バス*コンポーネントに注目してください。 これは、メッセージ ブローカーをカプセル化し、基になるアプリケーションから切り離すカスタム クラスです。 注文と在庫のマイクロサービスは、互いの知識もショッピング バスケット マイクロサービスも知らずに、独立してイベントを操作します。 登録されたイベントがイベント バスに発行されると、イベント バスに対して動作します。

イベント処理では、キューイング技術から*トピック*に移行します。 [トピック](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions)はキューに似ていますが、一対多のメッセージング パターンをサポートします。 1 つのマイクロサービスがメッセージをパブリッシュします。 複数のサブスクライブ マイクロサービスは、そのメッセージを受信して処理することを選択できます。 図 4-16 にトピック アーキテクチャを示します。

![トピックアーキテクチャ](./media/topic-architecture.png)

**図 4-16**.  トピックアーキテクチャ

前の図では、パブリッシャーはトピックにメッセージを送信します。 最後に、サブスクライバーはサブスクリプションからメッセージを受信します。 中央では、トピックは、濃い青色のボックスに表示される一連の*ルール*に基づいて、サブスクリプションにメッセージを転送します。 ルールは、特定のメッセージをサブスクリプションに転送するフィルターとして機能します。 ここでは、サブスクリプション 1 とサブスクリプション\#\#3 に "CreateOrder" イベントが送信されますが\#、サブスクリプション 2 には送信されません。 "OrderCompleted" イベントは、サブスクリプション 2\#とサブスクリプション\#3 に送信されます。

Azure クラウドでは、2 つの異なるトピック サービスがサポートされています: Azure サービス バス トピックと Azure イベント グリッド。

### <a name="azure-service-bus-topics"></a>Azure Service Bus トピック

Azure サービス バス キューの同じ堅牢な仲介メッセージ モデルの上に座って[Azure サービス バスのトピックです](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions)。 トピックは、複数の独立したパブリッシャーからのメッセージを受信し、最大 2,000 人のサブスクライバーにメッセージを送信できます。 サブスクリプションは、システムを停止したりトピックを再作成したりすることなく、実行時に動的に追加または削除できます。

Azure Service Bus キューの多くの高度な機能は、[重複データ検出](https://docs.microsoft.com/azure/service-bus-messaging/duplicate-detection)や[トランザクション サポート](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-transactions)などのトピックでも利用できます。 既定では、Service Bus のトピックは単一のメッセージ ブローカーによって処理され、単一のメッセージ ストアに格納されます。 ただし[、Service Bus パーティション分割](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-partitioning)では、トピックを多数のメッセージ ブローカーとメッセージ ストアに分散してスケーリングします。

[スケジュールされたメッセージ配信](https://docs.microsoft.com/azure/service-bus-messaging/message-sequencing)は、メッセージに特定の時間を処理するタグを付けます。 その時間より前にメッセージがトピックに表示されません。 [メッセージ遅延](https://docs.microsoft.com/azure/service-bus-messaging/message-deferral)により、後でメッセージの取得を延期できます。 どちらの操作も、特定の順序で処理されるワークフロー処理シナリオで一般的に使用されます。 受信したメッセージの処理は、前の作業が完了するまで延期できます。

Service Bus のトピックは、クラウド ネイティブ システムでパブリッシュ/サブスクライブ通信を可能にする、堅牢で実証済みのテクノロジです。

### <a name="azure-event-grid"></a>Azure Event Grid

Azure Service Bus は、エンタープライズ機能の完全なセットを備えた戦闘テスト済みのメッセージング ブローカーですが[、Azure Event Grid](https://docs.microsoft.com/azure/event-grid/overview)はブロックの新しい子供です。

一見すると、Event Grid は、トピックベースのメッセージング システムのように見えるかもしれません。 しかし、それは多くの点で異なります。 イベント駆動型のワークロードに焦点を当て、リアルタイムのイベント処理、Azure の深い統合、オープン プラットフォーム (すべてサーバーレス インフラストラクチャ) を実現します。 現代的なクラウドネイティブアプリケーションとサーバーレスアプリケーション向けに設計されています。

イベント グリッドは、イベント*バックプレーン*(パイプ) の集中型として、Azure リソース内および独自のサービスからのイベントに対応します。

イベント通知はイベント グリッド トピックに発行され、各イベントはサブスクリプションにルーティングされます。 サブスクライバーはサブスクリプションにマップされ、イベントを消費します。 Service Bus と同様に、Event Grid は、サブスクリプションが受信するイベントのルールを設定する*フィルター処理されたサブスクライバー モデル*をサポートします。 Event Grid は、Azure Service Bus が生成できるものよりもはるかに多く、1 秒あたり 1,000 万イベントを保証することで高速スループットを実現します。

Event Grid の優れたスポットは、Azure インフラストラクチャのファブリックへの深い統合です。 Cosmos DB などの Azure リソースは、カスタム コードを必要とせずに、関連する他の Azure リソースに直接組み込みイベントを発行できます。 Event Grid では、Azure サブスクリプション、リソース グループ、またはサービスからイベントを発行できるため、開発者はクラウド リソースのライフサイクルを細かく制御できます。 ただし、イベント グリッドは Azure に限定されません。 アプリケーションまたはサードパーティサービスから公開されたカスタム HTTP イベントを使用して、外部のサブスクライバーにイベントをルーティングできるオープンプラットフォームです。

Azure リソースからネイティブ イベントを発行してサブスクライブする場合、コーディングは必要ありません。 簡単な構成では、トピックとサブスクリプションの組み込みの組み込み配管を使用して、Azure リソース間のイベントを統合できます。 図 4-17 に、イベント グリッドの解剖学を示します。

![イベントグリッドの解剖学](./media/event-grid-anatomy.png)

**図 4-17**.  イベントグリッドの解剖学

EventGrid とサービス バスの主な違いは、基になる*メッセージ交換パターン*です。

Service Bus は、下位のサブスクライバがトピック サブスクリプションをアクティブにポーリングして新しいメッセージを受け取る、古いスタイルの*プル モデル*を実装します。 逆に、このアプローチは、サブスクライバーがメッセージを処理するペースを完全に制御できるようにします。 特定の時点で処理するメッセージの数とタイミングを制御します。 未読メッセージは、処理されるまでサブスクリプションに残ります。 重大な欠点は、イベントが生成されてから、そのメッセージを処理のためにサブスクライバーにプルするポーリング操作との間の待機時間です。 また、次のイベントの一定のポーリングのオーバーヘッドは、リソースとお金を消費します。

しかし、イベントグリッドは異なります。 イベントが受信されると EventHandlers に送信され、ほぼリアルタイムのイベント配信を提供する*プッシュ モデル*を実装します。 また、ポーリングのようにイベントを消費する必要がある場合にのみサービスがトリガーされるため、コストが削減されます。 つまり、イベント ハンドラーは、着信負荷を処理し、自分自身が圧倒されないように、調整メカニズムを提供する必要があります。 Azure 関数やロジック アプリなど、これらのイベントを使用する多くの Azure サービスは、増加した負荷を処理するための自動自動スケール機能を提供します。  

Event Grid は、サーバーレスクラウドサービスを完全に管理しています。 トラフィックに基づいて動的にスケーリングされ、購入済みの容量ではなく、実際の使用量に対してのみ課金されます。 毎月の最初の 100,000 回の操作は無料で、イベント入力 (受信イベント通知)、サブスクリプションの配信試行、管理呼び出し、件名によるフィルタリングとして定義される操作です。 EventGrid は、99.99% の可用性を備えたイベントの配信を 24 時間以内に保証し、配信に失敗した場合に組み込みの再試行機能を備えています。 配信不能メッセージは、解決のために "配信不能" キューに移動できます。  Azure Service Bus とは異なり、Event Grid は高速なパフォーマンスを実現するように調整されており、順序付けられたメッセージング、トランザクション、セッションなどの機能はサポートしていません。

### <a name="streaming-messages-in-the-azure-cloud"></a>Azure クラウドでのメッセージのストリーミング

Azure Service Bus および Event Grid は、新しいドキュメントが Cosmos DB に挿入されたような 1 つの個別のイベントを公開するアプリケーションをサポートします。 しかし、クラウドネイティブシステムが*関連イベントのストリーム*を処理する必要がある場合はどうでしょうか? [イベント ストリーム](https://docs.microsoft.com/archive/msdn-magazine/2015/february/microsoft-azure-the-rise-of-event-stream-oriented-systems)はより複雑です。 通常、それらは時間順で相互に関連しており、グループとして処理する必要があります。

[Azure Event Hub](https://azure.microsoft.com/services/event-hubs/)は、イベントを収集、変換、および格納するデータ ストリーミング プラットフォームおよびイベント インジェスト サービスです。 テレメトリ コンテキストから生成された継続的なイベント通知など、ストリーミング データをキャプチャするように微調整されています。 このサービスは拡張性が高く、[毎秒数百万のイベントを](https://docs.microsoft.com/azure/event-hubs/event-hubs-about)保存して処理できます。 図 4-18 に示すように、多くの場合、このガイドは、イベント パイプラインのフロント ドアであり、取り込みストリームとイベント消費の分離を行います。

![Azure Event Hub](./media/azure-event-hub.png)

**図 4-18**. Azure Event Hub

Event Hub は、低待機時間と構成可能な時間の保持をサポートします。 Event Hubs は、キューやトピックとは異なり、コンシューマーが読み取った後もイベント データを保持します。 この機能により、内部と外部の両方の他のデータ分析サービスが、さらに分析するためにデータを再生できます。 イベント ハブに格納されたイベントは、保持期間が満了した時点でのみ削除されます。

イベント ハブは、HTTPS や AMQP などの一般的なイベント発行プロトコルをサポートしています。 また、カフカ 1.0 もサポートしています。 [既存の Kafka アプリケーションは、Kafka](https://docs.microsoft.com/azure/event-hubs/event-hubs-for-kafka-ecosystem-overview)プロトコルを使用してイベント ハブと通信でき、大規模な Kafka クラスタを管理する代わりに使用できます。 多くのオープンソースのクラウドネイティブシステムは、Kafkaを採用しています。

Event Hubs は、各コンシューマーがメッセージ ストリームの特定のサブセット (パーティション) のみを読み取る[、パーティション化されたコンシューマー モデル](https://docs.microsoft.com/azure/event-hubs/event-hubs-features)を通じてメッセージ ストリーミングを実装します。 このパターンでは、イベント処理の横の倍率を大きくすることができ、キューおよびトピックで使用できないその他のストリームに重点を置いた機能を提供します。 パーティションは、イベント ハブで保持される順序付けされた一連のイベントです。 新しいイベントが到着すると、このシーケンスの末尾に追加されます。図 4-19 は、イベント ハブでのパーティショニングを示しています。

![イベント ハブのパーティション分割](./media/event-hub-partitioning.png)

**図 4-19** イベント ハブのパーティション分割

各コンシューマー グループは、同じリソースから読み取るのではなく、メッセージ ストリームのサブセット (パーティション) を通して読み取ります。

大量のイベントをストリーミングする必要があるクラウド ネイティブ アプリケーションの場合、Azure Event Hub は堅牢で手頃な価格のソリューションになります。

>[!div class="step-by-step"]
>[前次](front-end-communication.md)
>[Next](rest-grpc.md)
