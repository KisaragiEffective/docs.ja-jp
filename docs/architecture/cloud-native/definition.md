---
title: クラウド ネイティブの定義
description: クラウドネイティブシステムの基盤となる基礎的な柱について学ぶ
author: robvet
ms.date: 08/20/2019
ms.openlocfilehash: 27191a67b2964ac2e1636a4d7dc55d5314b78439
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/14/2020
ms.locfileid: "79401737"
---
# <a name="defining-cloud-native"></a>クラウド ネイティブの定義

[!INCLUDE [book-preview](../../../includes/book-preview.md)]

あなたがやっていることを停止し、あなたの同僚の10をテキスト。 「クラウド ネイティブ」という用語を定義するように依頼します。 あなたは8つの異なる答えを得る可能性が高いです。 興味深いことに、クラウドネイティブのテクノロジやプラクティスが進化するにつれて、6 か月後に、その定義も進化します。

クラウドネイティブは、重要なビジネスシステムの構築に対する考え方を変える方法です。

クラウドネイティブシステムは、急速な変化、大規模、および回復力を採用するように設計されています。

クラウドネイティブコンピューティング財団は[、公式の定義](https://github.com/cncf/foundation/blob/master/charter.md)を提供します:

> *クラウドネイティブテクノロジにより、組織は、パブリック クラウド、プライベート クラウド、ハイブリッド クラウドなどの最新の動的環境でスケーラブルなアプリケーションを構築し、実行できます。コンテナー、サービス メッシュ、マイクロサービス、不変インフラストラクチャ、および宣言型 API は、このアプローチを例示しています。*

> *これらの手法により、弾力性、管理性、観察性を備えた疎結合システムが実現します。堅牢な自動化と組み合わせることで、エンジニアは最小限の苦労で頻繁かつ予測可能に影響の大きな変更を行うことを可能にします。*

アプリケーションは、ますます多くのユーザーを要求して複雑になっています。 ユーザーは、迅速な応答性、革新的な機能、およびダウンタイムをゼロに期待します。 パフォーマンスの問題、繰り返し発生するエラー、および高速に移動できない場合は、もはや許容されません。 彼らは簡単にあなたの競争相手に移動します。

クラウドネイティブは、*スピード*と*敏捷性*について多くのです。 ビジネスシステムは、ビジネス能力の実現から戦略的変革の武器まで進化し、ビジネスのスピードと成長を加速しています。 アイデアをすぐに市場に投入することが不可欠です。

これらの技術を実装した企業をいくつか紹介します。 達成したスピード、俊敏性、拡張性について考えてみてください。

| [会社] | エクスペリエンス |
| :-------- | :-------- |
| [Netflix](https://www.infoq.com/news/2013/06/netflix/) | 生産に600以上のサービスを持っています。 1 日に 100 回展開します。 |
| [ユーバー](https://eng.uber.com/micro-deploy/) | 1,000以上のサービスが本番環境に保存されています。 毎週数千のビルドを展開します。 |
| [WeChat](https://www.cs.columbia.edu/~ruigu/papers/socc18-final100.pdf) | 生産に300以上のサービスを持っています。 1 日あたり約 1,000 の変更を行います。 |

ご覧のとおり、Netflix、Uber、WeChat は、何百もの独立したマイクロサービスで構成されるシステムを公開しています。 この建築様式は市場の状況に迅速に対応することを可能にする。 ライブの複雑なアプリケーションの小さな領域を瞬時に更新し、必要に応じて個別に拡張できます。

クラウドネイティブのスピードと俊敏性は、多くの要因から生じます。 最も重要なのはクラウド インフラストラクチャです。 図 1-3 に示す 5 つの追加の基礎柱は、クラウド ネイティブ システムの基盤も提供します。

![クラウドネイティブ基礎柱](./media/cloud-native-foundational-pillars.png)

**図 1-3**. クラウドネイティブ基礎柱

各柱の重要性を理解するために少し時間を取りましょう。

## <a name="the-cloud"></a>クラウド.

クラウド ネイティブ システムは、クラウド サービス モデルを最大限に活用します。

動的な仮想化クラウド環境での繁栄を目的として設計されたこれらのシステムは、[プラットフォームをサービスとして(PaaS)](https://azure.microsoft.com/overview/what-is-paas/)コンピューティングインフラストラクチャとマネージドサービスを幅広く利用しています。 基盤となるインフラストラクチャは、数分でプロビジョニングされ、オートメーションによってサイズ変更、拡大縮小、移動、または破棄される *、使い捨て*として扱われます。

[ペット対牛](https://medium.com/@Joachim8675309/devops-concepts-pets-vs-cattle-2380b5aab313)の広く受け入れられているDevOpsの概念を考えてみましょう。 従来のデータセンターでは、サーバーは*Pets*として扱われます: 物理マシン、意味のある名前を与えられ、世話をします。 同じマシンにリソースを追加してスケールアップします (スケールアップ)。 サーバーが病気になった場合は、健康に戻って看護します。 サーバーが使用できなくなった場合、全員が通知します。

*牛*のサービスモデルは異なります。 各インスタンスを仮想マシンまたはコンテナーとしてプロビジョニングします。 これらは同じで、Service-01、Service-02 などのシステム識別子が割り当てられています。 スケールするには、その他のサイズを作成します (スケール アウト)。 1つが利用できなくなったら、誰も気付かない。

牛モデルは*不変のインフラを*受け入れています。 サーバーは修復も変更もされません。 1 つが失敗した場合、または更新が必要な場合は、破棄され、新しいものがプロビジョニングされます。

クラウドネイティブシステムは、牛サービスモデルを採用しています。 インフラストラクチャは、実行しているマシンに関係なく、スケールインまたはスケールアウトに応じて実行し続けます。

Azure クラウド プラットフォームは、自動スケーリング、自己修復、および監視機能を備えた、この種の高弾性インフラストラクチャをサポートします。

## <a name="modern-design"></a>モダン デザイン

クラウドネイティブアプリをどのように設計しますか? アーキテクチャはどのようなものでしょうか。 どのような原則、パターン、およびベスト プラクティスを遵守しますか。 どのようなインフラストラクチャと運用上の懸念が重要でしょうか。

### <a name="the-twelve-factor-application"></a>12要素アプリケーション

クラウドベースのアプリケーションを構築するための広く受け入れられている方法論は[、12要素アプリケーションです](https://12factor.net/)。 開発者が最新のクラウド環境向けに最適化されたアプリケーションを構築するために従う一連の原則と実践について説明します。 環境間の移植性と宣言型オートメーションには特に注意が必要です。

Web ベースのアプリケーションに適用できる一方で、多くの実務者はクラウドネイティブアプリを構築するための強固な基盤と考えています。 これらの原則に基づいて構築されたシステムは、迅速に展開および拡張し、市場の変化に迅速に対応する機能を追加できます。

次の表は、12 要素の方法論を示しています。

|    |  要素 | 説明  |
| :-------- | :-------- | :-------- |
| 1 | コードベース | マイクロサービスごとに 1 つのコード ベースを独自のリポジトリに格納します。 バージョン管理で追跡され、複数の環境(QA、ステージング、本番)に展開できます。 |
| 2 | 依存関係 | 各マイクロサービスは、システム全体に影響を与えることなく変更を受け入れ、独自の依存関係を分離してパッケージ化します。 |
| 3 | 構成  | 構成情報は、マイクロサービスから移動され、コードの外部にある構成管理ツールを通じて外部化されます。 正しい構成が適用された環境に同じ配置を適用できます。  |
| 4 | バッキングサービス | 補助リソース (データ ストア、キャッシュ、メッセージ ブローカー) は、アドレス指定可能な URL を介して公開する必要があります。 これにより、アプリケーションからリソースが切り離され、交換可能になります。  |
| 5 | ビルド、リリース、実行 | 各リリースでは、ビルド、リリース、および実行の各段階で厳密な分離を強制する必要があります。 それぞれが一意の ID でタグ付けされ、ロールバックする機能をサポートする必要があります。 最新のCI/CDシステムは、この原則を達成するのに役立ちます。 |
| 6 | 処理 | 各マイクロサービスは、他の実行中のサービスから分離された独自のプロセスで実行する必要があります。 分散キャッシュやデータ ストアなどのバッキング サービスに必要な状態を外部化します。 |
| 7 | [ポートのバインド] | 各マイクロサービスは、独自のポートで公開されるインターフェイスと機能を持つ自己完結型である必要があります。 これにより、他のマイクロサービスから分離できます。 |
| 8 | コンカレンシー | サービスは、利用可能な最も強力なマシン上の単一の大規模なインスタンスをスケールアップするのではなく、多数の小さな同一プロセス (コピー) にまたがってスケールアウトします。 |
| 9 | ディスポスタビリティ | サービス インスタンスは、システムを正しい状態にする場合は、高速スタートアップを優先してスケーラビリティの機会を増やし、適切なシャットダウンを行う必要があります。 Docker コンテナーとオーケストレーターは、本質的にこの要件を満たします。 |
| 10 | 開発/プロッド パリティ | アプリケーションのライフサイクル全体にわたって環境を可能な限り同じに保ち、コストのかかるショートカットを回避します。 ここでは、同じ実行環境を推進することで、コンテナの採用に大きく貢献できる。 |
| 11 | ログ記録 | マイクロサービスによって生成されたログをイベント ストリームとして扱います。 イベント アグリゲータを使用して処理し、データを Azure Monitor や Splunk などのデータ マイニング/ログ管理ツールに反映し、最終的には長期的なアーカイブを行います。 |
| 12 | 管理プロセス | 管理/管理タスクを一時処理として実行します。 タスクには、レポートのデータクリーンアップとプル分析を含めることができます。 これらのタスクを実行するツールは、アプリケーションとは別に、運用環境から呼び出す必要があります。 |

本の中で、 [十二因子アプリを超えて](https://content.pivotal.io/blog/beyond-the-twelve-factor-app), 著者ケビン・ホフマンは、元の12の要因のそれぞれを詳述します (2011年に書かれました). さらに、この書籍には、今日の最新のクラウド アプリケーションの設計を反映する 3 つの追加要素が示されています。

|    |  新しい要因 | 説明  |
| :-------- | :-------- | :-------- |
| 13 | API ファースト | すべてをサービスにします。 コードがフロントエンド クライアント、ゲートウェイ、または別のサービスによって使用されると仮定します。 |
| 14 | テレメトリ | ワークステーションでは、アプリケーションとその動作を詳細に把握できます。 クラウドでは、あなたはしません。 監視、ドメイン固有、および正常性/システム データの収集が設計に含まれていることを確認します。 |
| 15 | 認証/承認  | 最初から ID を実装します。 パブリック クラウドで利用できる[RBAC (ロールベースのアクセス制御)](https://docs.microsoft.com/azure/role-based-access-control/overview)機能を検討してください。  |

この章と本の中の12以上の要因の多くを参照します。

### <a name="critical-design-considerations"></a>設計上の重要な考慮事項

12 要素の方法論から提供されるガイダンスを超えて、分散システムを構築する際に行う必要があるいくつかの重要な設計上の決定があります。

*通信*

フロントエンド クライアント アプリケーションは、バックエンドのコア サービスとどのように通信しますか。 直接コミュニケーションを許可しますか? または、柔軟性、制御、およびセキュリティを提供するゲートウェイ ファサードを使用してバックエンド サービスを抽象化する場合もあります。

バックエンドコアサービスは、どのように相互に通信しますか。 直接的な HTTP 呼び出しを許可して、パフォーマンスと俊敏性に影響を与える可能性がありますか。 または、キューとトピックのテクノロジを使用して、メッセージングを分離することを検討する必要がありますか。

コミュニケーションの詳細については、第 4 章*クラウド ネイティブの通信パターンを説明*します。

*復元*

マイクロサービス アーキテクチャは、システムをインプロセスからネットワーク通信に移行します。 分散環境では、サービス B がサービス A からの呼び出しに応答しない場合は、どのような操作を行いますか。 サービス C が一時的に利用できなくなり、サービス C を呼び出す他のサービスがスタックし、システムのパフォーマンスが低下した場合はどうなりますか。

復元力については、6 章クラウド*ネイティブの復元力*について詳しく説明します。

*分散データ*

仕様上、各マイクロサービスは独自のデータをカプセル化し、パブリック インターフェイスを介して操作を公開します。 その場合、データをクエリしたり、複数のサービス間でトランザクションを実装したりする方法はありますか。

分散データについては、第 5 章*クラウド ネイティブ データ パターン*で詳しく説明します。

*Id*

サービスは、アクセスするユーザーと、そのサービスにアクセスできるアクセス許可をどのように識別しますか。

アイデンティティについては、第8章 の*アイデンティティについて詳しく説明*しています。

## <a name="microservices"></a>マイクロサービス

クラウド ネイティブ システムは、最新のアプリケーションを構築するための一般的なアーキテクチャ スタイルであるマイクロサービスを採用しています。

共有ファブリックを介して対話する小規模で独立したサービスの分散セットとして構築されたマイクロサービスは、次の特性を共有します。

- 各ユーザーは、より大きなドメイン コンテキスト内で特定のビジネス機能を実装します。

- それぞれが自律的に開発され、独立して展開することができます。

- それぞれが独自のデータストレージ技術(SQL、NoSQL)とプログラミングプラットフォームをカプセル化しています。

- それぞれが独自のプロセスで実行され、HTTP/HTTPS、WebSockets、AMQPなどの標準通信プロトコルを使用して他[AMQP](https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol)のユーザーと通信します。

- それらは、アプリケーションを形成するために一緒に構成します。

図 1-4 は、マイクロサービス アプローチとモノリシック アプリケーション アプローチを対比したものです。 モノリスが、単一のプロセスで実行される階層化アーキテクチャで構成されている方法に注意してください。 通常、リレーショナル データベースを使用します。 ただし、マイクロサービスのアプローチでは、機能がロジックとデータを含む独立したサービスに分離されます。 各マイクロサービスは、独自のデータストアをホストします。

![モノリシック展開とマイクロサービス](./media/monolithic-vs-microservices.png)

**図1-4。** モノリシック展開とマイクロサービス

マイクロサービスが、この章で前に説明した[12 要素アプリケーション](https://12factor.net/)から「1 つのコードベース、1 つのアプリケーション」の原則をどのように推進しているかを確認します。

> *演算\#項目 1 は、"マイクロサービスごとに 1 つのコードベースを指定し、独自のリポジトリに格納します。バージョン管理で追跡することで、複数の環境に展開できます。*

### <a name="why-microservices"></a>マイクロサービスについて

マイクロサービスは機敏性を提供します。

この章の前半では、モノリスとして構築された e コマース アプリケーションをマイクロサービスと比較しました。 この例では、明確な利点を示しています。

- 各マイクロサービスには自律的なライフサイクルがあり、独立して進化し、頻繁にデプロイできます。 新しい機能や更新プログラムを展開するために、四半期ごとのリリースを待つ必要はありません。 複雑なアプリケーションの小さな領域を更新し、システム全体を混乱させるリスクを軽減できます。

- 各マイクロサービスは、個別にスケールできます。 アプリケーション全体を単一のユニットとして拡張するのではなく、処理能力やネットワーク帯域幅を必要とするサービスのみをスケールアウトします。 このきめ細かなスケーリングアプローチにより、システムの制御性が向上し、すべてではなくシステムの一部をスケールする際に全体的なコストを削減できます。

マイクロサービスを理解するための優れたリファレンス ガイドは[、.NET マイクロサービス: コンテナー化された .NET アプリケーションのアーキテクチャです](https://docs.microsoft.com/dotnet/standard/microservices-architecture/)。 本書では、マイクロサービスの設計とアーキテクチャについて詳しく説明しています。 これは、Microsoft から無料でダウンロードできる[フルスタック マイクロサービスリファレンス アーキテクチャ](https://github.com/dotnet-architecture/eShopOnContainers)のコンパニオンです。

### <a name="developing-microservices"></a>マイクロサービスの開発

マイクロサービスは、あらゆる最新の開発プラットフォームで作成できます。

Net コア プラットフォームは優れた選択肢です。 無料でオープンソースで、マイクロサービス開発を簡素化する多くの組み込み機能を備えています。 .NET Core はクロスプラットフォームです。 アプリケーションは、Windows、macOS、および Linux のほとんどのフレーバーで構築および実行できます。

.NET Core はパフォーマンスが高く、Node.js やその他の競合プラットフォームと比較して優れたスコアを獲得しています。 興味深いことに[、TechEmpower](https://www.techempower.com/)は、多くの Web アプリケーション プラットフォームとフレームワークにわたって、広範な[パフォーマンス ベンチマーク](https://www.techempower.com/benchmarks/#section=data-r17&hw=ph&test=plaintext)を実施しました。 .NET Core はトップ 10 に入った - Node.js と他の競合するプラットフォームをはるかに上回っています。

.NET Core は、マイクロソフトと GitHub の .NET コミュニティによって管理されています。

## <a name="containers"></a>Containers

今日では、*クラウドネイティブ*に関する会話で言及された*コンテナ*という用語を聞くのは当然です。 著者のコーネリア・デイビスは、「コンテナはクラウド[ネイティブ](https://www.manning.com/books/cloud-native-patterns)ソフトウェアの偉大なイネーブラーです」と述べています。 クラウド ネイティブ コンピューティングファウンデーションでは、[クラウド ネイティブ のトレイル マップ](https://raw.githubusercontent.com/cncf/trailmap/master/CNCF_TrailMap_latest.png)の最初のステップとしてマイクロサービスのコンテナー化を行います。

マイクロサービスのコンテナー化は簡単で簡単です。 コード、その依存関係、およびランタイムは、[コンテナー イメージ](https://docs.docker.com/glossary/?term=image)と呼ばれるバイナリにパッケージ化されます。 イメージは[、イメージ](https://caylent.com/container-registries/)のリポジトリまたはライブラリとして機能するコンテナー レジストリに格納されます。 レジストリは、開発用コンピューター、データセンター、またはパブリック クラウドに配置できます。 Docker 自体は[、Docker Hub](https://hub.docker.com/)経由でパブリック レジストリを維持します。 Azure クラウドには、[コンテナー](https://azure.microsoft.com/services/container-registry/)イメージを実行するクラウド アプリケーションの近くに格納するためのコンテナー レジストリが備わっています。

必要に応じて、イメージを実行中のコンテナインスタンスに変換します。 インスタンスは[、コンテナー ランタイム](https://kubernetes.io/docs/setup/production-environment/container-runtimes/)エンジンがインストールされているコンピューターで実行されます。 コンテナー化されたサービスのインスタンスは、必要に応じていくつでも持つことができます。

図 1-5 は、それぞれが 1 つのホストで実行されている、それぞれ独自のコンテナー内の 3 つの異なるマイクロサービスを示しています。

![コンテナー ホストで実行されている複数のコンテナー](./media/hosting-mulitple-containers.png)

**図 1-5**. コンテナー ホストで実行されている複数のコンテナー

各コンテナーが独自の依存関係とランタイムのセットを維持する方法に注意してください。 ここでは、同じホストで実行されている製品マイクロサービスの異なるバージョンが表示されます。 各コンテナーは、基になるホスト オペレーティング システム、メモリ、およびプロセッサのスライスを共有しますが、互いに分離されます。

コンテナモデルが[十二要素アプリケーション](https://12factor.net/)の「依存関係」原理をどの程度受け入れるかに注意してください。

> *演算\#項目 2 は、「各マイクロサービスは、システム全体に影響を与えずに変更を受け入れ、独自の依存関係を分離してパッケージ化する」と指定しています。*

コンテナーは、Linux ワークロードと Windows ワークロードの両方をサポートします。 Azure クラウドは、両方を公然と受け入れています。 興味深いことに、Azure で最も人気のあるオペレーティング システムとなっているのは、Windows サーバーではなく Linux です。

いくつかのコンテナベンダーが存在する一方で、Dockerは市場のライオンのシェアを獲得しました。 同社はソフトウェアコンテナの動きを推進してきました。 クラウド ネイティブ アプリケーションのパッケージ化、デプロイ、実行の事実上の標準となっています。

### <a name="why-containers"></a>なぜコンテナ?

コンテナは、移植性を提供し、環境間で一貫性を保証します。 すべてを 1 つのパッケージにカプセル化することで、マイクロサービスとその依存関係を基盤となるインフラストラクチャから*分離*できます。

Docker ランタイム エンジンを持つ環境では、同じコンテナーをデプロイできます。 コンテナー化されたワークロードでは、フレームワーク、ソフトウェア ライブラリ、およびランタイム エンジンを使用して各環境を事前に構成するコストも削減できます。

基になるオペレーティング システムとホスト リソースを共有することで、コンテナーのフットプリントは、完全な仮想マシンよりもはるかに小さくなります。 サイズが小さいほど、特定のホストが一度に実行できる *、マイクロ*サービスの密度 (数) が増加します。

### <a name="container-orchestration"></a>コンテナーのオーケストレーション

Docker などのツールはイメージを作成し、コンテナーを実行しますが、それらを管理するためのツールも必要です。 コンテナ管理は、コンテナオーケストレーターと呼ばれる特別なソフトウェアプログラムで行います。 規模で動作する場合、コンテナー オーケストレーションは不可欠です。

図 1-6 に、コンテナー オーケストレーターが提供する管理タスクを示します。

![コンテナオーケストレーターが行うこと](./media/what-container-orchestrators-do.png)

**図 1-6**. コンテナオーケストレーターが行うこと

次の表は、一般的なオーケストレーション タスクを示しています。

|  処理手順 | 説明  |
| :-------- | :-------- |
| スケジュール設定 | コンテナインスタンスを自動的にプロビジョニングします。|
| アフィニティ/アンチアフィニティー | コンテナーを近くまたは離れた状態でプロビジョニングし、可用性とパフォーマンスを向上させます。 |
| 正常性の監視 | 障害を自動的に検出して修正します。|
| [フェールオーバー] | 正常なマシンに障害が発生したインスタンスを自動的に再プロビジョニングします。|
| Scaling | 要求に合わせて、コンテナー インスタンスを自動的に追加または削除します。|
| ネットワーク | コンテナ通信用のネットワーク オーバーレイを管理する。|
| サービス探索 | コンテナが互いを見つけ合えるようにします。|
| ローリングアップグレード | ダウンタイムゼロの展開で増分アップグレードを調整します。 問題のある変更を自動的にロールバックします。|

オーケストレーターが、この章で前に説明した[12 要素アプリケーション](https://12factor.net/)のディスポジビリティと同時実行性の原則をどのように受け入れるかについて注意してください。

> *演算\#項目 9 は、「サービス インスタンスは使い捨て可能で、高速スタートアップを優先してスケーラビリティの機会を増やし、システムを正しい状態にするグレースフル シャットダウンを優先する必要があります。Docker コンテナーとオーケストレーターは、本質的にこの要件を満たしています。*

> *第\#8 段階では、「サービスは、利用可能な最も強力なマシン上の単一の大きなインスタンスをスケールアップするのではなく、多数の小さな同一プロセス (コピー) にスケールアウトします。*

いくつかのコンテナオーケストレーターが存在する一方で[、Kubernetes](https://kubernetes.io/docs/concepts/overview/what-is-kubernetes/)はクラウドネイティブの世界の事実上の標準となっています。 コンテナ化されたワークロードを管理するための、移植可能で拡張性のあるオープンソースプラットフォームです。

Kubernetes の独自のインスタンスをホストすることもできますが、その後、リソースのプロビジョニングと管理を担当する必要があります。 Azure クラウドは、管理されたサービスである[Azure Kubernetes サービス (AKS) として Kubernetes を](https://azure.microsoft.com/services/kubernetes-service/)備えています。 マネージド サービスを使用すると、その機能を完全に活用でき、インストールと保守を行う必要がありません。

Azure Kubernetes サービスについては、詳細について説明します 2 章 クラウド*ネイティブ アプリケーションのスケーリング*.

## <a name="backing-services"></a>バッキングサービス

クラウド ネイティブ システムは、データ ストア、メッセージ ブローカー、監視、ID サービスなど、さまざまな補助リソースに依存します。 これらのサービスは、[バッキング サービス](https://12factor.net/backing-services)と呼ばれます。

 図 1-7 は、クラウド ネイティブ システムが使用する多くの一般的なバッキング サービスを示しています。

![共通のバッキングサービス](./media/common-backing-services.png)

**図 1-7**. 共通のバッキングサービス

支援サービスは、この章の前半で説明した[12要素アプリケーション](https://12factor.net/)から「無国籍」原則を推進しています。

>*演算\#項目 6*では、「各マイクロサービスは、他の実行中のサービスから分離された独自のプロセスで実行する必要があります。 分散キャッシュやデータ ストアなどのバッキング サービスに必要な状態を外部化します。

独自のバッキング サービスをホストすることもできますが、その後、これらのリソースのライセンス付与、プロビジョニング、管理を担当します。

クラウド プロバイダーは、*豊富な種類の管理されたバッキング サービスを提供します。* サービスを所有する代わりに、単にそれを消費します。 プロバイダは、大規模なリソースを運用し、パフォーマンス、セキュリティ、および保守に責任を負います。 監視、冗長性、可用性はサービスに組み込まれています。 プロバイダはマネージドサービスを完全にサポートしています - チケットを開くと、問題が解決されます。

クラウドネイティブシステムは、クラウドベンダーの管理バッキングサービスを優先します。 時間と労力の節約は大きい。 あなた自身をホストし、トラブルを経験する運用上のリスクは、高速で高価になる可能性があります。

ベスト プラクティスは、外部構成に格納された情報 (URL と資格情報) を含むマイクロサービスに動的にバインドされた、*アタッチされたリソース*としてバッキング サービスを扱います。 このガイダンスは、この章の前半で説明した[12 要素アプリケーション](https://12factor.net/)で説明されています。

>*演算\#項目 4*は、バッキング サービスをアドレス指定可能な URL を介して公開することを指定します。 これにより、アプリケーションからリソースが切り離され、交換可能になります。

>*演算\#項目 3*は、「構成情報はマイクロサービスから移動され、コードの外部の構成管理ツールを通じて外部化される」と指定します。

このパターンでは、コードを変更せずにバッキング サービスをアタッチおよびデタッチできます。 マイクロサービスを QA からステージング環境に昇格させる場合があります。 マイクロサービス構成を更新してステージングのバッキング サービスをポイントし、環境変数を使用してコンテナーに設定を挿入します。

クラウド ベンダーは、独自のバッキング サービスと通信するための API を提供します。 これらのライブラリは、配管と複雑さをカプセル化します。 これらの API と直接通信すると、コードがバッキング サービスに密接に結合されます。 ベンダー API の実装の詳細を絶縁する方が良い方法です。 仲介レイヤー (中間 API) を導入し、サービス コードに汎用操作を公開します。 この疎結合により、1 つのバッキング サービスを別のバッキング サービスに交換したり、メインライン サービス コードを変更することなくコードを別のパブリック クラウドに移動したりできます。

バッキング サービスについては、第 5 章、*クラウド ネイティブ データ パターン*、および第 4 章*のクラウド ネイティブ通信パターン*について詳しく説明します。

## <a name="automation"></a>Automation

ご覧のとおり、クラウド ネイティブ システムにはマイクロサービス、コンテナー、モダン システム設計が採用されており、スピードと俊敏性を実現できます。 しかし、それは物語の一部に過ぎません。 これらのシステムを実行するクラウド環境をどのようにプロビジョニングしますか。 アプリの機能と更新プログラムを迅速に展開する方法 どのように全体像を丸めるのですか?

広く受け入れられているインフラストラクチャのプラクティスをコード 、または IaC[として](https://docs.microsoft.com/azure/devops/learn/what-is-infrastructure-as-code)入力します。

IaC を使用すると、プラットフォームのプロビジョニングとアプリケーションの展開を自動化できます。 基本的には、テストやバージョン管理などのソフトウェア エンジニアリングプラクティスを DevOps プラクティスに適用します。 インフラストラクチャと展開は自動化され、一貫性があり、繰り返し可能です。

### <a name="automating-infrastructure"></a>インフラストラクチャの自動化

Azure[リソース マネージャー](https://azure.microsoft.com/documentation/articles/resource-group-overview/)、Terraform、および[Azure CLI](https://docs.microsoft.com/cli/azure/)などのツールを使用すると、必要なクラウド インフラストラクチャを宣言的にスクリプト化できます。 リソース名、場所、容量、およびシークレットはパラメーター化され、動的です。 スクリプトはバージョン管理され、プロジェクトの成果物としてソース管理にチェックインされます。 QA、ステージング、本番などのシステム環境全体で一貫性のある繰り返し可能なインフラストラクチャをプロビジョニングするには、スクリプトを呼び出します。

このフードの下では、IaCはべき等であり、副作用を伴わずに同じスクリプトを何度も実行できます。 チームが変更を加える必要がある場合は、スクリプトを編集して再実行します。 更新されたリソースのみが影響を受けます。

記事では、[コードとしてのインフラストラクチャとは何か](https://docs.microsoft.com/azure/devops/learn/what-is-infrastructure-as-code)、著者サム・グッケンハイマーは、「IaCを実装するチームは、迅速かつ大規模に安定した環境を提供することができます。 チームは、手動で環境を構成することを回避し、コードを使用して環境の目的の状態を表すことによって整合性を強制します。 IaC を使用したインフラストラクチャの展開は繰り返し可能であり、構成のドリフトや依存関係の欠落によって発生するランタイムの問題を防ぎます。 DevOpsチームは、統一された一連のプラクティスとツールと連携して、アプリケーションとそのサポートインフラストラクチャを迅速かつ確実に、かつ大規模に提供できます。

### <a name="automating-deployments"></a>展開の自動化

[前述の 12 要素アプリケーション](https://12factor.net/)では、完成したコードを実行中のアプリケーションに変換する場合に、個別の手順を実行します。

> *演算\#項目 5*は、「各リリースでは、ビルド、リリース、および実行の各段階で厳密な分離を強制する必要があります。 それぞれが一意の ID でタグ付けされ、ロールバックする機能をサポートする必要があります。

最新のCI/CDシステムは、この原則を達成するのに役立ちます。 これらは、個別の展開手順を提供し、ユーザーがすぐに利用できる一貫性のある高品質のコードを確保するのに役立ちます。

図 1-8 は、展開プロセス全体の分離を示しています。

![CI/CD パイプラインの展開手順](./media/build-release-run-pipeline.png)

**図 1-8**. CI/CD パイプラインでの展開手順

前の図では、タスクの分離に特に注意を払ってください。

開発者は、開発環境で、コードの "内部ループ" と呼ばれるものを反復処理し、実行し、デバッグする機能を構築します。 完了すると、コードは GitHub、Azure DevOps、BitBucket などのコード リポジトリに*プッシュされます*。

このプッシュは、コードをバイナリアーティファクトに変換するビルドステージをトリガーします。 この作業は[、継続的インテグレーション (CI)](https://martinfowler.com/articles/continuousIntegration.html)パイプラインを使用して実装されます。 アプリケーションのビルド、テスト、およびパッケージが自動的に行われます。

リリース・ステージは、バイナリ成果物を取り出し、外部アプリケーションおよび環境構成情報を適用し、不変リリースを生成します。 リリースは指定された環境にデプロイされます。 この作業は[、継続的デリバリー (CD)](https://martinfowler.com/bliki/ContinuousDelivery.html)パイプラインで実装されます。 各リリースは識別可能である必要があります。 "この展開は、アプリケーションのリリース 2.1.1 を実行しています" と言うことができます。

最後に、リリースされた機能は、ターゲットの実行環境で実行されます。 リリースは変更が不変であることを意味し、変更によって新しいリリースが作成される必要があります。

これらのプラクティスを適用することで、組織はソフトウェアの出荷方法を根本的に進化させてきました。 多くは四半期ごとのリリースからオンデマンド更新に移行しました。 目標は、問題を修正するコストが低い場合に、開発サイクルの早い段階で問題をキャッチすることです。 統合の間の期間が長いほど、問題の解決にコストがかかります。  統合プロセスの一貫性により、チームはコード変更をより頻繁にコミットできるため、コラボレーションとソフトウェアの品質が向上します。

### <a name="azure-pipelines"></a>Azure Pipelines

Azure クラウドには、図 1-9 に示す[Azure DevOps](https://azure.microsoft.com/services/devops/)の提供の一部である Azure[パイプライン](https://azure.microsoft.com/services/devops/pipelines/)という新しい CI/CD サービスが含まれています。

![Azure パイプライン (DevOps)](./media/devops-components.png)

**図 1-9**. Azure DevOps 製品

Azure パイプラインは、継続的インテグレーション (CI) と継続的デリバリー (CD) を組み合わせたクラウド サービスです。 コードを自動的にテスト、ビルド、および任意のターゲットに送信できます。

アプリの残りのコードと共に、YAML ファイル内のコードでパイプラインを定義します。

- パイプラインはコードでバージョン管理され、同じ分岐構造に従います。
- プル要求と分岐ビルド ポリシーのコード レビューを通じて、変更の検証を受けます。
- 使用するすべてのブランチは、azure-pipelines.yml ファイルを変更することでビルドポリシーをカスタマイズできます。
- パイプライン ファイルはバージョン管理にチェックインされ、問題が発生した場合に調査できます。

Azure Pipelines サービスは、ほとんどの Git プロバイダーをサポートし、Linux、macOS、または Windows プラットフォームで記述されたアプリケーションのデプロイ パイプラインを生成できます。 これには、Java、.NET、JavaScript、Python、PHP、囲碁、XCode、およびC++のサポートが含まれています。

>[!div class="step-by-step"]
>[前次](introduction.md)
>[Next](candidate-apps.md)
